<!DOCTYPE HTML>
<html lang="Chinese" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第一期傲来操作系统训练营基础阶段学习引导</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="introduce.html"><strong aria-hidden="true">2.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="ch1-00.html"><strong aria-hidden="true">3.</strong> 第一章 - 第 1 课(上) - 操作系统简介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1-01.html"><strong aria-hidden="true">3.1.</strong> 什么是操作系统</a></li><li class="chapter-item expanded "><a href="ch1-02.html"><strong aria-hidden="true">3.2.</strong> 为什么要有操作系统</a></li><li class="chapter-item expanded "><a href="ch1-03.html"><strong aria-hidden="true">3.3.</strong> RISC-V：操作系统的未来发展方向</a></li></ol></li><li class="chapter-item expanded "><a href="ch2-00.html"><strong aria-hidden="true">4.</strong> 第二章 - 第 1 课(下) - 操作系统结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2-01.html"><strong aria-hidden="true">4.1.</strong> 结构的重要性</a></li><li class="chapter-item expanded "><a href="ch2-02.html"><strong aria-hidden="true">4.2.</strong> 宏内核 & 微内核</a></li><li class="chapter-item expanded "><a href="ch2-03.html"><strong aria-hidden="true">4.3.</strong> 外核 + libOS</a></li><li class="chapter-item expanded "><a href="ch2-04.html"><strong aria-hidden="true">4.4.</strong> 多内核 / 复内核</a></li></ol></li><li class="chapter-item expanded "><a href="ch3-00.html"><strong aria-hidden="true">5.</strong> 第三章 - 第 2 课(全) - 中断、异常与系统调用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch3-01.html"><strong aria-hidden="true">5.1.</strong> 中断和异常</a></li><li class="chapter-item expanded "><a href="ch3-02.html"><strong aria-hidden="true">5.2.</strong> 系统调用</a></li></ol></li><li class="chapter-item expanded "><a href="ch4-00.html"><strong aria-hidden="true">6.</strong> 第四章 - 第 3 课(上) - 系统初始化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch4-01.html"><strong aria-hidden="true">6.1.</strong> 计算机的启动</a></li><li class="chapter-item expanded "><a href="ch4-02.html"><strong aria-hidden="true">6.2.</strong> BIOS</a></li><li class="chapter-item expanded "><a href="ch4-03.html"><strong aria-hidden="true">6.3.</strong> EFI / UEFI</a></li><li class="chapter-item expanded "><a href="ch4-04.html"><strong aria-hidden="true">6.4.</strong> Grub、Init 与 RunLevel</a></li></ol></li><li class="chapter-item expanded "><a href="ch5-00.html"><strong aria-hidden="true">7.</strong> 第五章 - 第 3 课(下) - Risc-V 的初始化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch5-01.html"><strong aria-hidden="true">7.1.</strong> 启动流程和链接脚本</a></li><li class="chapter-item expanded "><a href="ch5-02.html"><strong aria-hidden="true">7.2.</strong> 初始化</a></li><li class="chapter-item expanded "><a href="ch5-03.html"><strong aria-hidden="true">7.3.</strong> Risc-V 设备从上电到运行</a></li></ol></li><li class="chapter-item expanded "><a href="ch6-00.html"><strong aria-hidden="true">8.</strong> 第六章 - 题目分析[1 - 9]</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch6-01.html"><strong aria-hidden="true">8.1.</strong> 实验代码框架讲解</a></li><li class="chapter-item expanded "><a href="ch6-02.html"><strong aria-hidden="true">8.2.</strong> 第一题 - MakeFile - 编写第一份 MakeFile</a></li><li class="chapter-item expanded "><a href="ch6-03.html"><strong aria-hidden="true">8.3.</strong> 第二题 - MakeFile - 编写用于测试的 MakeFile</a></li><li class="chapter-item expanded "><a href="ch6-04.html"><strong aria-hidden="true">8.4.</strong> 第三题 - MakeFile - 静态链接程序</a></li><li class="chapter-item expanded "><a href="ch6-05.html"><strong aria-hidden="true">8.5.</strong> 第四题 - MakeFile - 构建第一个静态链接库</a></li><li class="chapter-item expanded "><a href="ch6-06.html"><strong aria-hidden="true">8.6.</strong> 第五题 - MakeFile - 构建第一个动态链接库</a></li><li class="chapter-item expanded "><a href="ch6-07.html"><strong aria-hidden="true">8.7.</strong> 第六题 - ld 脚本 - 指定内存区域</a></li><li class="chapter-item expanded "><a href="ch6-08.html"><strong aria-hidden="true">8.8.</strong> 第七题 - ld 脚本 - 指定 text 起始地址</a></li><li class="chapter-item expanded "><a href="ch6-09.html"><strong aria-hidden="true">8.9.</strong> 第八题 - ld 脚本 - 指定自定义 symbol</a></li><li class="chapter-item expanded "><a href="ch6-10.html"><strong aria-hidden="true">8.10.</strong> 第九题 - ld 脚本 - 指定自定义 section</a></li></ol></li><li class="chapter-item expanded "><a href="ch7-00.html"><strong aria-hidden="true">9.</strong> 第七章 - 题目分析[10 - 20]</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch7-01.html"><strong aria-hidden="true">9.1.</strong> 第十题 - 数据结构(队列) - 合并两个队列</a></li><li class="chapter-item expanded "><a href="ch7-02.html"><strong aria-hidden="true">9.2.</strong> 第十一题 - 数据结构(队列) - 按组反转一个队列</a></li><li class="chapter-item expanded "><a href="ch7-03.html"><strong aria-hidden="true">9.3.</strong> 第十二题 - 内核模块 - 打印 hello world</a></li><li class="chapter-item expanded "><a href="ch7-04.html"><strong aria-hidden="true">9.4.</strong> 第十三题 - 内核模块 - 阶乘计算</a></li><li class="chapter-item expanded "><a href="ch7-05.html"><strong aria-hidden="true">9.5.</strong> 第十四题 - 内核模块 - 字符串反转</a></li><li class="chapter-item expanded "><a href="ch7-06.html"><strong aria-hidden="true">9.6.</strong> 第十五题 - 内核模块 - 平均数计算</a></li><li class="chapter-item expanded "><a href="ch7-07.html"><strong aria-hidden="true">9.7.</strong> 第十六题 - 内核模块 - 线性查找</a></li><li class="chapter-item expanded "><a href="ch7-08.html"><strong aria-hidden="true">9.8.</strong> 第十七题 - 内核模块 - 延时打印字符串</a></li><li class="chapter-item expanded "><a href="ch7-09.html"><strong aria-hidden="true">9.9.</strong> 第十八题 - Risc-V 汇编 - 条件返回</a></li><li class="chapter-item expanded "><a href="ch7-10.html"><strong aria-hidden="true">9.10.</strong> 第十九题 - Risc-V 汇编 - 最大公因数求解</a></li><li class="chapter-item expanded "><a href="ch7-11.html"><strong aria-hidden="true">9.11.</strong> 第二十题 - Risc-V 汇编 - 数组元素查找</a></li></ol></li><li class="chapter-item expanded "><a href="ap-A.html"><strong aria-hidden="true">10.</strong> 附录 A - 可供参考的各种资料汇总</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">第一期傲来操作系统训练营基础阶段学习引导</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p><strong>本文档旨在为读者提供一个关于操作系统深入理解的指南，并在基础阶段提供必要的知识和实践任务。</strong></p>
<h2 id="本书大纲"><a class="header" href="#本书大纲">本书大纲</a></h2>
<p>本书从操作系统的基本概念开始，逐步深入到其内部结构和实现机制。全书分为多个章节，每个章节都围绕一个核心主题进行展开，旨在帮助读者系统地掌握操作系统的相关知识。</p>
<ul>
<li><strong>第一章</strong>：介绍了操作系统的基本概念，包括什么是操作系统、为什么要有操作系统，以及 RISC-V 作为操作系统未来发展方向的展望。</li>
<li><strong>第二章</strong>：详细讨论了操作系统的结构，包括宏内核、微内核、外核+libOS 以及多内核/复内核等不同的架构模式，并分析了它们各自的优缺点。</li>
<li><strong>第三章</strong>：讲解了中断、异常和系统调用的概念及其在操作系统中的作用，为后续章节中讨论系统资源管理打下基础。</li>
<li><strong>第四章</strong>和<strong>第五章</strong>：关注于系统初始化过程，从计算机的启动、BIOS、EFI/UEFI，到 Grub、Init 与 RunLevel，再到 Risc-V 的初始化流程，为读者展示了从硬件上电到操作系统运行的整个过程。</li>
<li><strong>第六章</strong>和<strong>第七章</strong>：提供了丰富的实践任务，包括 Makefile 的编写、链接脚本（ld script）的定制、数据结构的操作、内核模块的编程以及 Risc-V 汇编的实践等，旨在通过实践加深读者对操作系统理论知识的理解。</li>
<li><strong>附录 A</strong>：汇总了可供参考的各种资料，为读者提供了进一步学习和研究的方向。</li>
</ul>
<h2 id="读者的任务"><a class="header" href="#读者的任务">读者的任务</a></h2>
<p>在基础阶段，读者需要了解操作系统的基本概念、结构以及初始化过程，掌握中断、异常和系统调用的基本概念和作用。同时，读者还需要完成一些实践任务，如编写 Makefile、定制链接脚本、编写内核模块和 Risc-V 汇编代码等，通过实践加深对操作系统理论知识的理解和应用。</p>
<p>我们鼓励读者在阅读本书的同时，积极思考并尝试解决遇到的问题，通过不断的学习和实践，逐步提高自己的能力。希望本书能够成为读者在傲来操作系统基础阶段学习道路上的良师益友。</p>
<h2 id="反馈与贡献"><a class="header" href="#反馈与贡献">反馈与贡献</a></h2>
<p>如果您有任何意见、建议或疑问，欢迎随时通过 GitHub 上的 <a href="https://github.com/kunyuanxu-star/eulixos-camp-book-stage1/issues">issues</a> 页面进行反馈。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<h2 id="傲来操作系统"><a class="header" href="#傲来操作系统">傲来操作系统</a></h2>
<p>傲来操作系统（EulixOS）是由中科院软件所 / 中科南京软件技术研究院团队基于 openEuler 打造的操作系统发行版，其开发目标是集成软件所的最新科研成果，面向开源爱好者、科研人员和学生，为在线服务、高性能计算、AI 计算等使用场景提供一款安全、易用的操作系统。</p>
<h2 id="文档概述"><a class="header" href="#文档概述">文档概述</a></h2>
<p>本文档基于傲来操作系统训练营第一期的基础阶段课程内容与作业内容，为您提供一份较为简单易用的学习指南。但请注意，您可以将本文档看作您在傲来操作系统训练营基础阶段的一份<strong>知识地图</strong>，而不是一份完整详细的教程。我们会简要介绍上课讲的知识点和完成作业所需要掌握的知识点，但不会过于详细深入。如果有兴趣，可以自行去深入了解对应方向。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一章---第-1-课上---操作系统简介"><a class="header" href="#第一章---第-1-课上---操作系统简介">第一章 - 第 1 课(上) - 操作系统简介</a></h1>
<h2 id="本章概要"><a class="header" href="#本章概要">本章概要</a></h2>
<p>在本章中，本文档将深入探索操作系统的基本概念，以及它在计算机领域中的核心地位。</p>
<p>首先，在第一节，本文档将从“什么是操作系统”这一基础问题出发，为初学者揭开操作系统的神秘面纱。本文档将解释操作系统的定义，分析操作系统的功能，了解操作系统在计算机里的角色。</p>
<p>本文档将会在第二节探讨“为什么要有操作系统”这一关键问题。本文档已经介绍过了操作系统的功能，在这部分，本文档会通过一些实际场景，为读者介绍操作系统在现在社会的重要作用。</p>
<p>在本章的最后一节中，本文档将介绍操作系统的未来发展方向：RISC-V。RISC-V 是一种基于精简指令集（RISC）的开源硬件指令集架构（ISA），它正逐渐成为操作系统开发的新星。本文档将介绍 RISC-V 架构的重要价值。</p>
<p>通过本章的学习，读者将对操作系统的基本概念、历史发展、核心功能以及未来趋势有一个全面的了解，为后续深入学习操作系统打下坚实的基础。</p>
<h2 id="本章目录"><a class="header" href="#本章目录">本章目录</a></h2>
<ul>
<li><a href="./ch1-01.html">什么是操作系统</a></li>
<li><a href="./ch1-02.html">为什么要有操作系统</a></li>
<li><a href="./ch1-03.html">RISC-V：操作系统的未来发展方向</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是操作系统"><a class="header" href="#什么是操作系统">什么是操作系统</a></h1>
<h2 id="本节目录"><a class="header" href="#本节目录">本节目录</a></h2>
<ul>
<li><a href="ch1-01.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">什么是操作系统</a>
<ul>
<li><a href="ch1-01.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch1-01.html#%E7%A1%AC%E4%BB%B6%E5%92%8C%E5%BA%94%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B1%82">硬件和应用之间的软件层</a></li>
<li><a href="ch1-01.html#%E4%B8%BA%E5%BA%94%E7%94%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E9%83%A8%E5%88%86%E6%9C%8D%E5%8A%A1">为应用提供的部分服务</a></li>
<li><a href="ch1-01.html#%E5%BA%94%E7%94%A8%E7%9A%84%E9%83%A8%E5%88%86%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">应用的部分管理功能</a></li>
</ul>
</li>
</ul>
<h2 id="硬件和应用之间的软件层"><a class="header" href="#硬件和应用之间的软件层">硬件和应用之间的软件层</a></h2>
<p>操作系统是硬件和应用之间的软件层。<br />
一方面它提供了硬件操作接口和系统调用，来帮助应用程序来访问和利用硬件资源，还负责应用程序的加载和调度，来确保硬件资源的有效利用；<br />
另一方面它还控制硬件设备来完成各种功能，并且对硬件进行抽象，使得应用程序的开发者，不再需要关注于硬件的差异。</p>
<p>对于操作系统的位置和作用，可以参考下图：
<img src="./resource/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E4%BB%80%E4%B9%88.png" alt="操作系统是什么" /></p>
<p>通过上面的图，我们可以看到，操作系统与硬件之间的关系比较好理解，所以，我们接下来将会详细看看，操作系统到底为了应用提供了哪些服务和管理。</p>
<h2 id="为应用提供的部分服务"><a class="header" href="#为应用提供的部分服务">为应用提供的部分服务</a></h2>
<p>在实际应用中，操作系统主要为应用提供了下面列出的一系列服务。但由于想要举出例子，必须涉及到操作系统的一些特殊名词，在编撰本文档时，默认同学们已经通过导学阶段，对于操作系统的一下名词有了初步的认识，所以建议同学们在遇到看不懂的地方时，可以复习一下涉及到的名词。</p>
<p>以下是操作系统为应用程序提供的具体服务内容：</p>
<ul>
<li><strong>计算资源的抽象</strong>
<ul>
<li>CPU：通过<strong>进程</strong>或<strong>线程</strong>的调度，应用程序不再直接受限于物理 CPU 的数量。</li>
<li>内存：提供<strong>虚拟内存</strong>机制，使得应用程序的内存大小、连续性和隔离性不再受物理内存的限制。</li>
<li>I/O 设备：将各种 I/O 设备统一抽象为<strong>文件</strong>接口，为应用程序提供统一的访问方式。</li>
</ul>
</li>
<li><strong>线程间的同步</strong>
<ul>
<li>应用程序可以实现自己的同步原语（如<strong>lock</strong>），但操作系统通常提供更高效、更底层的同步机制。</li>
<li>操作系统提供的同步原语（如<strong>futex</strong>）与线程切换紧密结合，以优化性能。</li>
</ul>
</li>
<li><strong>进程间的通信</strong>
<ul>
<li>应用程序可以利用网络进行进程间通信（如通过<strong>loopback 设备</strong>）。</li>
<li>操作系统提供了更高效的本地通信机制（如<strong>pipe</strong>），这些机制通常具有更丰富的语义和更优化的性能。</li>
</ul>
</li>
</ul>
<p>其它服务不再举例，有兴趣的同学可以自行了解。</p>
<h2 id="应用的部分管理功能"><a class="header" href="#应用的部分管理功能">应用的部分管理功能</a></h2>
<p>现代应用程序普遍支持高并发，而这种对高并发的处理能力在很大程度上依赖于操作系统的支持。以下是操作系统为应用程序提供的一些关键管理功能：</p>
<ul>
<li>
<p>应用生命周期管理</p>
<ul>
<li><strong>加载</strong>：操作系统负责将应用程序加载到内存中，并准备其执行环境。</li>
<li><strong>迁移</strong>：在某些情况下，操作系统可以将正在运行的应用程序从一个物理或虚拟环境迁移到另一个环境，以保持服务的连续性和负载均衡。</li>
<li><strong>销毁</strong>：当应用程序不再需要或发生错误时，操作系统负责清理其占用的资源并终止其执行。</li>
</ul>
</li>
<li>
<p>计算资源分配</p>
<ul>
<li><strong>CPU</strong>：操作系统通过调度机制，根据优先级、时间片轮转或其他策略来分配 CPU 资源给不同的应用程序。</li>
<li><strong>内存</strong>：操作系统管理内存分配，确保每个应用程序有足够的内存空间来执行其任务，同时避免内存泄漏和溢出。</li>
<li><strong>I/O 设备</strong>：操作系统提供设备的复用和分配机制，确保多个应用程序可以安全、高效地访问共享的 I/O 设备。</li>
</ul>
</li>
<li>
<p>安全与隔离</p>
<ul>
<li><strong>应用程序内部</strong>：操作系统提供访问控制机制，确保应用程序只能访问其被授权的资源，防止内部的安全漏洞和错误。</li>
<li><strong>应用程序之间</strong>：
<ul>
<li><strong>错误隔离</strong>：操作系统通过进程、线程或容器等技术实现应用程序之间的错误隔离，确保一个应用程序的错误不会影响其他应用程序的正常运行。</li>
<li><strong>性能隔离</strong>：操作系统通过资源配额、优先级调度等技术实现应用程序之间的性能隔离，确保每个应用程序都能获得其所需的计算资源，避免资源竞争导致的性能下降。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过上述管理功能，操作系统为应用程序提供了一个稳定、高效、安全的运行环境，使其能够支持高并发并应对各种复杂的业务场景。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为什么要有操作系统"><a class="header" href="#为什么要有操作系统">为什么要有操作系统</a></h1>
<h2 id="本节目录-1"><a class="header" href="#本节目录-1">本节目录</a></h2>
<ul>
<li><a href="ch1-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">为什么要有操作系统</a>
<ul>
<li><a href="ch1-02.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch1-02.html#%E5%BA%94%E7%94%A8%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%A3%E8%80%A6">应用与操作系统的解耦</a></li>
<li><a href="ch1-02.html#%E7%89%B9%E6%9D%83%E7%BA%A7%E7%9A%84%E5%BC%95%E5%85%A5">特权级的引入</a></li>
<li><a href="ch1-02.html#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E5%8C%96">操作系统的分化</a></li>
<li><a href="ch1-02.html#%E5%AF%B9%E7%A1%AC%E4%BB%B6cpu%E7%9A%84%E8%A6%81%E6%B1%82">对硬件（CPU）的要求</a></li>
<li><a href="ch1-02.html#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%BC%94%E5%8C%96">操作系统的两种演化</a></li>
<li><a href="ch1-02.html#%E7%9B%AE%E5%89%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E9%94%AE%E4%BD%9C%E7%94%A8">目前操作系统的关键作用</a></li>
</ul>
</li>
</ul>
<h2 id="应用与操作系统的解耦"><a class="header" href="#应用与操作系统的解耦">应用与操作系统的解耦</a></h2>
<p>在最早的时候，是完全没有“操作系统”这个概念的。这时的应用程序，将所有的功能都汇聚到了一起，开发人员身兼数职，从磁盘读写到程序逻辑，一切都需亲手操持。</p>
<p>然而，随着技术的进步和需求的增长，应用程序的功能日益丰富，代码量也如滚雪球般不断膨胀。开发人员发现，维护这样一个庞大的、功能混杂的程序变得越来越困难。为了解决这个问题，人们开始尝试将应用程序的底层存储和逻辑工作分开，将它们各自封装成独立的模块。</p>
<p>这种“分化”带来了革命性的变化。开发人员可以将一些常用的底层存储和逻辑工作（如磁盘读写、内存管理等）封装成特定的模块，这些模块通过统一的接口与其他模块进行交互。这样，开发人员就可以更加专注于应用程序的核心逻辑，而无需过多关注底层细节。而这些被封装好的模块，提供了非常丰富的功能，使得我们在开发时，只需要调用这些库的接口，就能获得所需的功能，而无需从头开始编写代码。</p>
<p>看到这里，你是不是想到了什么？没错，这时的这些模块，其实就类似我们现在常用的“库”，只需要调用其接口，就能得到想要的结果。但是，问题来了，既然这些“库”就已经能够较优的构成应用程序了，那么为什么还需要操作系统呢？</p>
<h2 id="特权级的引入"><a class="header" href="#特权级的引入">特权级的引入</a></h2>
<p>想要回答上面的问题，我们必须了解一段计算机的发展史。最早的计算机，使用纸带进行参数配置、代码录入等工作，这极为不便。后续，人们为了解决计算机计算速度远高于人类录入速度的矛盾，开发了批处理系统。但批处理系统一时间只能处理一个任务，无法同时处理多个任务，导致一旦某任务过程中，发出了 I/O 请求，CPU 就必须等待该请求完成，这段时间就导致了 CPU 资源的浪费。因此，人们再次升级计算机，开发了多道程序系统。</p>
<p>多道程序系统，通过时分复用计算资源的方式，在一台计算机上同时运行多个应用程序。但同时运行，就带来了一个新的问题：如何保证不同应用间的隔离？假设有两个程序，它们都能随意使用硬件设备，第一个应用希望关机，第二个应用则希望格式化硬盘，那么最终的结果就很可能是，两个应用彼此干扰，硬盘只格式化了一半。</p>
<p>为了解决上面的问题，人们只好引入了“特权级”的概念，至少具有两个特权级，即，位于低权限时，不能对计算机的全局状态进行任何改变；而高权限时，则集中运行能够操控整个计算机的代码。我们称这部分代码所执行后，能改变全局状态的操作，为<strong>特权操作</strong>，在高权限状态，慢慢分化出了<strong>操作系统</strong>（的内核）。</p>
<p>有兴趣了解更多操作系统历史的同学们，可以通过<a href="https://www.cnblogs.com/Dominic-Ji/articles/10929381.html">此链接</a>，查看更多内容。</p>
<h2 id="操作系统的分化"><a class="header" href="#操作系统的分化">操作系统的分化</a></h2>
<p>操作系统的分化阶段，大致如下图所示：
<img src="./resource/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E5%8C%96.png" alt="操作系统的分化" /></p>
<h2 id="对硬件cpu的要求"><a class="header" href="#对硬件cpu的要求">对硬件（CPU）的要求</a></h2>
<p>在引入权限级后，对硬件也提出了更多的要求。</p>
<p>对于 CPU 来说，具体的改变如下所示：</p>
<ul>
<li>将 CPU 对软件提供的接口称为 ISA
<ul>
<li>ISA: Instruction Set Architecture，中文译作<strong>指令集架构</strong>。</li>
<li>ISA 内，包含软件可见、可操作的接口，这些接口内包含各种指令和寄存器等。</li>
</ul>
</li>
<li>CPU 也相应分化出两个模式：非特权模式和特权模式
<ul>
<li>非特权模式 ISA：应用可使用的指令和寄存器</li>
<li>特权模式 ISA：只有操作系统才可使用的指令和寄存器</li>
</ul>
</li>
</ul>
<p>通常，我们将特权模式称为<strong>内核态</strong>，将非特权模式称为<strong>用户态</strong>。将从用户态切换到内核态的指令，称为<strong>特权指令</strong>。</p>
<h2 id="操作系统的两种演化"><a class="header" href="#操作系统的两种演化">操作系统的两种演化</a></h2>
<ul>
<li>外部 -&gt; 接口的演化：更好地应对新场景
<ul>
<li>POSIX 接口：定义了一组系统调用的接口，用来为应用提供兼容性</li>
<li>Linux：系统调用不断有新的加入、旧的退出</li>
<li>鸿蒙：分布式软总线等</li>
</ul>
</li>
<li>内部 -&gt; 架构的演化：
<ul>
<li>更好地应对复杂性：宏内核架构、微内核架构、外核架构、多内核架构等</li>
<li>为了更好的扩展性、容错性、安全性、兼容性、灵活性、性能等</li>
</ul>
</li>
</ul>
<p>对于上面的演化内容，大家可以依照自己兴趣和时间安排，进行了解。</p>
<h2 id="目前操作系统的关键作用"><a class="header" href="#目前操作系统的关键作用">目前操作系统的关键作用</a></h2>
<p>以下部分，引用了老师的 PPT：</p>
<p><img src="./resource/OS%E4%BD%9C%E7%94%A81.png" alt="" /></p>
<p><img src="./resource/OS%E4%BD%9C%E7%94%A82.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="risc-v操作系统的未来发展方向"><a class="header" href="#risc-v操作系统的未来发展方向">RISC-V：操作系统的未来发展方向</a></h1>
<h2 id="本节目录-2"><a class="header" href="#本节目录-2">本节目录</a></h2>
<ul>
<li><a href="ch1-03.html#risc-v%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91">RISC-V：操作系统的未来发展方向</a>
<ul>
<li><a href="ch1-03.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch1-03.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%9B%86">什么是“指令集”</a></li>
<li><a href="ch1-03.html#risc-v-%E7%9A%84%E9%87%8D%E8%A6%81%E4%BB%B7%E5%80%BC">Risc-V 的重要价值</a></li>
</ul>
</li>
</ul>
<h2 id="什么是指令集"><a class="header" href="#什么是指令集">什么是“指令集”</a></h2>
<p>指令集架构(Instruction Set Architecture，ISA)，简称指令集，是计算机系统中硬件与软件之间分界线和交互规范标准，，也是软硬件生态的起始原点。其位于计算机内的地位如下图所示：</p>
<p><img src="./resource/%E6%8C%87%E4%BB%A4%E9%9B%86.png" alt="" /></p>
<p>对于当前的指令集领域，尚未形成一套国际通用的标准。与操作系统采用 Posix 作为标准、数据库采用 SQL 作为标准的情况不同，指令集尚未实现标准化。这意味着，指令集的标准化工作仍在进行之中。其中，RISC-V 作为一种新兴的指令集架构，正逐渐崭露头角。</p>
<p>RISC-V 指令集=基础指令集+标准扩展指令集+用户自定义扩展指令集，而软件则是目前 Risc-V 生态中最关注的部分。现在已形成的 RISC-V 软件生态栈如下图所示：</p>
<p><img src="./resource/RV%E7%94%9F%E6%80%81%E6%A0%88.png" alt="" /></p>
<h2 id="risc-v-的重要价值"><a class="header" href="#risc-v-的重要价值">Risc-V 的重要价值</a></h2>
<p>对于我国而言，我们的基础软件领域暂时存在一定的短板，而 RISC-V 带来的“造轮子”的机会，恰好可以弥补这一空白。其可能的应用如下图所示：</p>
<p><img src="./resource/RV%E5%BA%94%E7%94%A8.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二章---第-1-课下---操作系统结构"><a class="header" href="#第二章---第-1-课下---操作系统结构">第二章 - 第 1 课(下) - 操作系统结构</a></h1>
<h2 id="本章概要-1"><a class="header" href="#本章概要-1">本章概要</a></h2>
<p>在本章中，本文档将进一步深入探索操作系统的结构部分。操作系统的结构决定了其如何管理计算机硬件和软件资源，如何为用户提供高效、安全和稳定的服务。本章将详细阐述操作系统结构的重要性，分析不同的操作系统架构，并探讨它们对系统性能和功能的影响。</p>
<p>首先，本文档将在第一节讨论操作系统结构的重要性。随着计算机系统的不断发展和复杂化，操作系统的结构也变得越来越重要。一个合理的操作系统结构可以有效地降低系统的复杂性，提高系统的可维护性和可扩展性。本文档将通过一些实际例子（如 Workplace），说明复杂性对操作系统设计和实现的影响，并探讨如何通过分离策略与机制来降低复杂性。</p>
<p>接下来，本文档将按照操作系统架构的历史演进，进行剩余节的讲解。第二节将会较为详细的介绍现代的宏内核、微内核架构。第三节将会主要介绍外核+库 OS 架构，第四节将会介绍多内核/复内核架构。</p>
<p>本文档将在各自的节，分析不同架构的特点和优缺点，并探讨它们在不同应用场景下的适用性。通过这些讲解，读者将会进一步理解在第一节中给出的，不同架构的示意图和实例，和各种架构之间的差异和联系。</p>
<p>通过对本章的学习，读者将对操作系统的结构有更深入的理解，掌握不同架构的特点和优缺点，为后续项目阶段的选择提供基本的介绍。</p>
<h2 id="本章目录-1"><a class="header" href="#本章目录-1">本章目录</a></h2>
<ul>
<li><a href="./ch2-01.html">结构的重要性</a></li>
<li><a href="./ch2-02.html">宏内核 &amp; 微内核</a></li>
<li><a href="./ch2-03.html">外核 + libOS</a></li>
<li><a href="./ch2-04.html">多内核 / 复内核</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构的重要性"><a class="header" href="#结构的重要性">结构的重要性</a></h1>
<h2 id="本节目录-3"><a class="header" href="#本节目录-3">本节目录</a></h2>
<ul>
<li><a href="ch2-01.html#%E7%BB%93%E6%9E%84%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">结构的重要性</a>
<ul>
<li><a href="ch2-01.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch2-01.html#%E5%A4%8D%E6%9D%82%E6%80%A7">复杂性</a></li>
<li><a href="ch2-01.html#%E6%83%B3%E5%8A%9E%E6%B3%95%E9%99%8D%E4%BD%8E%E5%85%B6%E5%A4%8D%E6%9D%82%E6%80%A7">想办法降低其复杂性</a></li>
<li><a href="ch2-01.html#%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%85%B6%E6%BC%94%E8%BF%9B">历史上的架构与其演进</a></li>
</ul>
</li>
</ul>
<h2 id="复杂性"><a class="header" href="#复杂性">复杂性</a></h2>
<p>1991-1995 年，IBM 公司投入 20 亿美元打造 Workplace 操作系统，然而，由于目标过于宏伟，系统过于复杂等种种原因，导致该项目最终失败，20 亿美元的投资打了水漂。同时，此项目的失败，也间接导致 IBM 全力投入扶植 Linux 操作系统。</p>
<p>上面的这个例子，应该可以让同学们看到，整个操作系统的复杂性有多么可怕。而在深入分析其“复杂性”来源时，我们可以发现：在操作系统内部，不同目标之间往往存在冲突，而在不同需求之间又需要进行权衡。</p>
<p>对于用户来说，操作系统应该方便使用、容易学习、功能齐全、安全流畅；但对于整个系统目标来说，操作系统应该容易设计与实现，容易维护，具有高灵活性、高可靠性和高效性。这就导致操作系统的复杂性居高不下。</p>
<h2 id="想办法降低其复杂性"><a class="header" href="#想办法降低其复杂性">想办法降低其复杂性</a></h2>
<p>而为了降低其复杂性，计算机科学家们提出：要将策略和机制进行分离，操作系统只能通过调整策略而不是机制来适配解决实际问题。</p>
<p>以调度算法为例，RR、FIFO 等都是策略，但调度队列、对线程的表示等，都是机制。</p>
<h2 id="历史上的架构与其演进"><a class="header" href="#历史上的架构与其演进">历史上的架构与其演进</a></h2>
<p>接下来，我们会给大家展示架构的发展历史和各种架构的对比。
<img src="./resource/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.png" alt="" />
<img src="./resource/%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏内核--微内核"><a class="header" href="#宏内核--微内核">宏内核 &amp; 微内核</a></h1>
<h2 id="本节目录-4"><a class="header" href="#本节目录-4">本节目录</a></h2>
<ul>
<li><a href="ch2-02.html#%E5%AE%8F%E5%86%85%E6%A0%B8--%E5%BE%AE%E5%86%85%E6%A0%B8">宏内核 &amp; 微内核</a>
<ul>
<li><a href="ch2-02.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch2-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%8F%E5%86%85%E6%A0%B8">什么是宏内核</a></li>
<li><a href="ch2-02.html#%E5%AE%8F%E5%86%85%E6%A0%B8%E7%9A%84%E4%BC%98%E7%82%B9">宏内核的优点</a></li>
<li><a href="ch2-02.html#%E5%AE%8F%E5%86%85%E6%A0%B8%E7%9A%84%E7%BC%BA%E7%82%B9">宏内核的缺点</a></li>
<li><a href="ch2-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%86%85%E6%A0%B8">什么是微内核</a></li>
<li><a href="ch2-02.html#%E5%BE%AE%E5%86%85%E6%A0%B8%E7%9A%84%E4%BC%98%E7%82%B9">微内核的优点</a></li>
<li><a href="ch2-02.html#%E5%BE%AE%E5%86%85%E6%A0%B8%E7%9A%84%E7%BC%BA%E7%82%B9">微内核的缺点</a></li>
<li><a href="ch2-02.html#%E5%AE%8F%E5%86%85%E6%A0%B8-vs-%E5%BE%AE%E5%86%85%E6%A0%B8">宏内核 vs 微内核</a></li>
<li><a href="ch2-02.html#%E6%B7%B7%E5%90%88%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84">混合内核架构</a></li>
</ul>
</li>
</ul>
<h2 id="什么是宏内核"><a class="header" href="#什么是宏内核">什么是宏内核</a></h2>
<p>在宏内核架构下，整个系统被分为内核与应用两层，内核运行在特权级，集中控制所有计算资源，应用运行在非特权级，受内核管理，使用内核提供的各种服务。更简明的解释如下图所示：</p>
<p><img src="./resource/%E5%AE%8F%E5%86%85%E6%A0%B8.png" alt="" /></p>
<h2 id="宏内核的优点"><a class="header" href="#宏内核的优点">宏内核的优点</a></h2>
<ul>
<li><strong>丰富的沉淀和积累</strong>：宏内核经过多年的发展，积累了丰富的功能和优化。</li>
<li><strong>巨大的统一的社区和生态</strong>：拥有庞大的用户群体和开发者社区，生态完善。</li>
<li><strong>针对不同场景的优化</strong>：经过 30 年的优化，宏内核能够针对各种场景提供高效的支持。</li>
</ul>
<h2 id="宏内核的缺点"><a class="header" href="#宏内核的缺点">宏内核的缺点</a></h2>
<ul>
<li><strong>安全性与可靠性问题</strong>：模块之间缺乏强隔离机制，可能导致安全隐患和可靠性问题。</li>
<li><strong>实时性支持</strong>：由于系统复杂，难以进行最坏情况时延分析，不利于实时应用。</li>
<li><strong>系统过于庞大</strong>：如 Linux 等宏内核系统代码行数庞大，可能阻碍了创新和灵活性。</li>
<li><strong>扩展性</strong>
<ul>
<li><strong>向上扩展</strong>：难以剪裁和扩展宏内核系统以支持从 KB 级别到 TB 级别的不同场景。</li>
<li><strong>向下扩展</strong>：同样存在扩展性挑战，难以满足极小化系统的需求。</li>
</ul>
</li>
<li><strong>硬件异构性</strong>：难以长期支持定制化的方式解决特定硬件问题。</li>
<li><strong>功能安全</strong>：例如 Linux，很难通过严格的功能安全认证（如汽车安全完整性认证 ASIL-D）。</li>
<li><strong>信息安全</strong>：单点错误可能导致整个系统出错，存在大量已知的安全问题（CVE）。</li>
<li><strong>确定性时延</strong>：虽然 Linux 花费了多年时间合并实时补丁，但目前仍不确定是否能支持确定性时延要求。</li>
</ul>
<h2 id="什么是微内核"><a class="header" href="#什么是微内核">什么是微内核</a></h2>
<p>在微内核架构下，采用“最小化内核功能”的方式，将操作系统功能移到用户态，称为"服务"(Server)，而在用户模块之间，使用消息传递机制通信。下图所示为微内核架构：</p>
<p><img src="./resource/%E5%BE%AE%E5%86%85%E6%A0%B8.png" alt="" /></p>
<h2 id="微内核的优点"><a class="header" href="#微内核的优点">微内核的优点</a></h2>
<ul>
<li><strong>易于扩展</strong>：直接添加一个用户进程即可为操作系统增加服务。</li>
<li><strong>易于移植</strong>：大部分模块与底层硬件无关。</li>
<li><strong>更加可靠</strong>：在内核模式运行的代码量大大减少。</li>
<li><strong>更加安全</strong>：即使存在漏洞，服务与服务之间存在进程粒度隔离。</li>
<li><strong>更加健壮</strong>：单个模块出现问题不会影响到系统整体。</li>
</ul>
<h2 id="微内核的缺点"><a class="header" href="#微内核的缺点">微内核的缺点</a></h2>
<ul>
<li><strong>性能较差</strong>：内核中的模块交互由函数调用变成了进程间通信。</li>
<li><strong>生态欠缺</strong>：尚未形成像 Linux 一样具有广泛开发者的社区。</li>
<li><strong>重用问题</strong>：重用宏内核操作系统提供兼容性，带来新问题。</li>
</ul>
<p>下面的图可以直观展示出微内核的性能缺陷：
<img src="./resource/%E5%BE%AE%E5%86%85%E6%A0%B8%E6%80%A7%E8%83%BD.png" alt="" /></p>
<p>有兴趣研究微内核的同学，可以自行查找相关资料学习。</p>
<h2 id="宏内核-vs-微内核"><a class="header" href="#宏内核-vs-微内核">宏内核 vs 微内核</a></h2>
<p>下面，我们对比一下宏内核和微内核。</p>
<p>它们的一个非常大的区别，在于共享数据状态。宏内核中，大量的共享状态在内核态；而微内核里，部分数据在内核态，部分在用户态。</p>
<p><img src="./resource/%E5%AE%8F%E5%86%85%E6%A0%B8%E5%BE%AE%E5%86%85%E6%A0%B8%E5%AF%B9%E6%AF%94.png" alt="" /></p>
<p>其次，在性能上，我们在上一部分已经展示出，对于某些情况下，微内核的性能会比宏内核差很多。</p>
<p>对于实际的操作流程，以“创建文件”为例：
<img src="./resource/%E5%AE%8F%E5%86%85%E6%A0%B8%E5%BE%AE%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6.png" alt="" /></p>
<h2 id="混合内核架构"><a class="header" href="#混合内核架构">混合内核架构</a></h2>
<p>既然宏内核和微内核各有优缺点，那么有没有一种架构，能够结合两者的优点，同时避免两者的缺点呢？</p>
<p>答案是有的，这就是混合内核架构。</p>
<p><img src="./resource/%E6%B7%B7%E5%90%88%E5%86%85%E6%A0%B8.png" alt="" /></p>
<p>混合内核架构，将需要性能的模块重新放回内核态，所以可以同时具备宏内核和微内核的优点，同时避免两者的缺点。</p>
<ul>
<li>Windows NT：微内核+内核态的系统服务+系统框架</li>
<li>macOS/i0S：Mach 微内核+BSD4.3+系统框架</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外核--libos"><a class="header" href="#外核--libos">外核 + libOS</a></h1>
<h2 id="本节目录-5"><a class="header" href="#本节目录-5">本节目录</a></h2>
<ul>
<li><a href="ch2-03.html#%E5%A4%96%E6%A0%B8--libos">外核 + libOS</a>
<ul>
<li><a href="ch2-03.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch2-03.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%96%E6%A0%B8%E4%B8%8E-libos">什么是外核与 libOS</a></li>
<li><a href="ch2-03.html#%E5%8D%95%E5%86%85%E6%A0%B8">单内核</a></li>
<li><a href="ch2-03.html#%E5%A4%96%E6%A0%B8%E7%9A%84%E4%BC%98%E7%82%B9">外核的优点</a></li>
<li><a href="ch2-03.html#%E5%A4%96%E6%A0%B8%E7%9A%84%E7%BC%BA%E7%82%B9">外核的缺点</a></li>
<li><a href="ch2-03.html#%E5%A4%96%E6%A0%B8-vs-%E8%99%9A%E6%8B%9F%E6%9C%BA">外核 VS 虚拟机</a></li>
</ul>
</li>
</ul>
<h2 id="什么是外核与-libos"><a class="header" href="#什么是外核与-libos">什么是外核与 libOS</a></h2>
<p>外核：</p>
<ul>
<li>Exokernel 不提供硬件抽象
<ul>
<li>“只要内核提供抽象，就不能实现性能最大化"</li>
<li>只有应用才知道最适合的抽象(end-to-end 原则)</li>
</ul>
</li>
<li>Exokernel 不管理资源，只管理应用
<ul>
<li>负责将计算资源与应用的绑定，以及资源的回收</li>
<li>保证多个应用之间的隔离</li>
</ul>
</li>
</ul>
<p>库 OS(Libos)：</p>
<ul>
<li>策略与机制分离：将对硬件的抽象以库的形式提供</li>
<li>高度定制化：不同应用可使用不同的 LibOS，或完全自定义</li>
<li>更高性能：Lib0s 与应用其他代码之间通过函数调用直接交互</li>
</ul>
<p>对于外核，图示如下：</p>
<p><img src="./resource/%E5%A4%96%E6%A0%B8.png" alt="" /></p>
<p>外核拥有与宏内核和微内核不同的功能，因此也提出了新的技术。</p>
<p>为了追踪计算资源的拥有权，采用了安全绑定(Secure binding)；为了保证资源的保护，采用了显式回收(Visible revocation)；同时，为了能够回收对资源的访问权，额外增加了中止协议(Abort protocol)。建议同学们对这部分内容进行自学。</p>
<h2 id="单内核"><a class="header" href="#单内核">单内核</a></h2>
<p>LibOS 可以进一步拓展为单内核，即一个内核管理多个应用。</p>
<p>单内核可以看做虚拟化环境下的 LibOS，每个虚拟机只使用内核态，在内核态中只运行一个应用和 LibOS，同时，通过虚拟化层实现不同实例间的隔离。</p>
<p>单内核非常适合容器应用场景，因为每个容器就是一个虚拟机，而且每个容器运行定制的 LibOS，可以有效提高性能。</p>
<p>对于单内核的开源项目，我们搜集到以下内容，感兴趣的同学可以进行自学：</p>
<ul>
<li>Rumprun：POSIX 接口，BSD 兼容的运行时环境，运行在 Xen 虚拟化平台之上</li>
<li>Drawbridge：来自微软，兼容 Win32 接口的运行时环境</li>
<li>OSv：与 Linux 兼容的应用环境，单地址空间</li>
</ul>
<p>同时，既然涉及到“LibOS”，就可以回到我们上一章提到的问题：操作系统能不能作为一个库？对于这个问题，有人提出了“Linux as a LibOS”，将 Linux 作为 LibOS 或 Unikernel 运行，但引入了很多新问题：</p>
<ul>
<li>Linux 是否适合作为 LibOS/unikernel?</li>
<li>fork()如何处理?</li>
</ul>
<p>此技术尚在探索阶段，感兴趣的同学可以进行自学。一个类似的例子是：LKL-Linux kernel library(https://github.com/lkl)</p>
<h2 id="外核的优点"><a class="header" href="#外核的优点">外核的优点</a></h2>
<ul>
<li>OS 无抽象，能在理论上提供最优性能</li>
<li>应用对计算有更精确的实时等控制</li>
<li>LibOS 在用户态更易调试，调试周期更短</li>
</ul>
<h2 id="外核的缺点"><a class="header" href="#外核的缺点">外核的缺点</a></h2>
<ul>
<li>对计算资源的利用效率主要由应用决定</li>
<li>定制化过多，导致维护难度增加</li>
</ul>
<h2 id="外核-vs-虚拟机"><a class="header" href="#外核-vs-虚拟机">外核 VS 虚拟机</a></h2>
<p>以下是对于外核与虚拟机的对比，感兴趣的同学可以搜集相关资料自学。</p>
<p><img src="./resource/%E5%A4%96%E6%A0%B8%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多内核--复内核"><a class="header" href="#多内核--复内核">多内核 / 复内核</a></h1>
<h2 id="本节目录-6"><a class="header" href="#本节目录-6">本节目录</a></h2>
<ul>
<li><a href="ch2-04.html#%E5%A4%9A%E5%86%85%E6%A0%B8--%E5%A4%8D%E5%86%85%E6%A0%B8">多内核 / 复内核</a>
<ul>
<li><a href="ch2-04.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch2-04.html#%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E7%9A%84%E8%83%8C%E6%99%AF">使用多内核架构的背景</a></li>
<li><a href="ch2-04.html#%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8E%9F%E5%9B%A0">使用多内核架构的原因</a></li>
<li><a href="ch2-04.html#%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%9E%E4%BE%8B">使用多内核架构的实例</a></li>
</ul>
</li>
</ul>
<h2 id="使用多内核架构的背景"><a class="header" href="#使用多内核架构的背景">使用多内核架构的背景</a></h2>
<ul>
<li>现在的 OS 内部维护很多共享状态
<ul>
<li>Cache 一致性的保证越来越难</li>
<li>可扩展性非常差，核数增多，性能不升反降</li>
</ul>
</li>
<li>GPU 等设备越来越多
<ul>
<li>设备本身越来越智能--设备有自己的 CPU</li>
<li>通过 PCle 连接，主 CPU 与设备 CPU 之间通信非常慢</li>
<li>通过系统总线连接，异构 SoC(Syslem on Chip)</li>
</ul>
</li>
</ul>
<p>对于 System on Chip，来说，其图解如下所示：
<img src="./resource/SoC.png" alt="System on Chip" /></p>
<p>以上的一系列背景，就使得使用多内核架构逐渐成为更优的解决方案。</p>
<h2 id="使用多内核架构的原因"><a class="header" href="#使用多内核架构的原因">使用多内核架构的原因</a></h2>
<ul>
<li>可以适配众核硬件平台</li>
<li>现有的 OS 架构在多核情况下，存在内核资源争用问题</li>
<li>现有的 OS 架构难以应对，应用混合部署下的性能隔离问题</li>
<li>现有的 OS 架构在异构硬件环境下资源利用率低</li>
</ul>
<h2 id="使用多内核架构的实例"><a class="header" href="#使用多内核架构的实例">使用多内核架构的实例</a></h2>
<p><img src="./resource/%E5%A4%9A%E6%A0%B8%E4%BE%8B%E5%AD%90.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第三章---第-2-课全---中断异常与系统调用"><a class="header" href="#第三章---第-2-课全---中断异常与系统调用">第三章 - 第 2 课(全) - 中断、异常与系统调用</a></h1>
<h2 id="本章概要-2"><a class="header" href="#本章概要-2">本章概要</a></h2>
<p>本章主要讨论了操作系统中三个核心概念：中断、异常和系统调用。这些概念在操作系统的设计和实现中起着至关重要的作用，它们共同构成了操作系统内核与用户空间程序之间交互的基础。</p>
<p>第一节内，我们讲了中断和异常。中断是计算机系统中一种重要的同步机制，用于通知 CPU 有外部事件或内部条件发生，需要 CPU 立即处理。当中断发生时，CPU 会暂停当前正在执行的程序，保存应用上下文，并跳转到相应的中断服务程序（ISR）去处理中断事件。处理完毕后，CPU 会恢复之前保存的现场信息，并继续执行被中断的程序。中断使得 CPU 能够高效地处理多任务，实现并发执行。</p>
<p>而异常是程序执行过程中发生的错误或异常条件，如除零错误、非法指令等。它与中断不同，异常是由 CPU 内部检测到的，并且通常是由程序错误导致的。CPU 会跳转到相应的异常处理程序去处理异常事件。异常处理完成后，CPU 会根据异常的性质选择恢复程序执行或终止程序。我们在第一节的末尾，将两者进行了对比。</p>
<p>之后的第二节，我们涉及到了系统调用。它是用户空间程序请求操作系统内核服务的一种机制。系统调用是用户空间与内核空间之间交互的桥梁，它使得用户空间程序能够访问底层硬件资源、执行特权操作以及实现进程管理、文件访问等功能。系统调用的实现依赖于中断机制，当用户空间程序发出系统调用请求时，CPU 会陷入内核态并执行相应的系统调用处理程序。我们在节内，进一步讨论了提高其性能的可能性。</p>
<h2 id="本章目录-2"><a class="header" href="#本章目录-2">本章目录</a></h2>
<ul>
<li><a href="./ch3-01.html">中断和异常</a></li>
<li><a href="./ch3-02.html">系统调用</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中断和异常"><a class="header" href="#中断和异常">中断和异常</a></h1>
<h2 id="本节目录-7"><a class="header" href="#本节目录-7">本节目录</a></h2>
<ul>
<li><a href="ch3-01.html#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8">中断和异常</a>
<ul>
<li><a href="ch3-01.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch3-01.html#%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%BD%AE%E8%AF%A2">中断与轮询</a></li>
<li><a href="ch3-01.html#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%9A%84%E5%AE%9A%E4%B9%89">中断与异常的定义</a></li>
<li><a href="ch3-01.html#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">处理流程</a></li>
<li><a href="ch3-01.html#trap-%E5%AE%9A%E4%B9%89">trap 定义</a></li>
<li><a href="ch3-01.html#%E5%9C%A8%E5%A4%84%E7%90%86-trap-%E6%97%B6%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8">在处理 trap 时使用到的寄存器</a></li>
<li><a href="ch3-01.html#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">异常处理函数</a></li>
<li><a href="ch3-01.html#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%AF%B9%E6%AF%94">中断和异常的对比</a></li>
</ul>
</li>
</ul>
<h2 id="中断与轮询"><a class="header" href="#中断与轮询">中断与轮询</a></h2>
<p>首先，我们假想一下，我们正在设计一个操作系统，现在，我们需要为它提供键盘支持。那么，我们如何实现这个功能？</p>
<p>一种方法是，我们使用轮询的方式，即，我们定期检查键盘的状态，如果键盘有输入，我们就处理它。但是，这种方式有一个问题，就是，如果键盘没有输入，那么，我们就会白白浪费 CPU 资源。那么，有没有更好的方法呢？有的，这就是中断。</p>
<p>中断是一种异步的事件处理机制。当某个事件发生时，操作系统会自动调用相应的处理函数来处理该事件。这样，我们就不用一直轮询键盘的状态了。</p>
<p>从上面这个例子，可以举一反三到更多的场景，如下图所示：</p>
<p><img src="./resource/%E8%BD%AE%E8%AF%A2.png" alt="" /></p>
<h2 id="中断与异常的定义"><a class="header" href="#中断与异常的定义">中断与异常的定义</a></h2>
<p>中断和异常的通用概念如下：</p>
<ul>
<li>中断(Interrupt) —— 异步异常
<ul>
<li>外部硬件设备所产生的信号</li>
<li>异步：产生原因和当前执行指令无关，如程序被磁盘读打断</li>
</ul>
</li>
<li>异常(Exception) —— 同步异常
<ul>
<li>软件的程序执行而产生的事件</li>
<li>同步：产生和当前执行或试图执行的指令相关</li>
</ul>
</li>
</ul>
<h2 id="处理流程"><a class="header" href="#处理流程">处理流程</a></h2>
<p>CPU 的执行逻辑很简单：</p>
<ol>
<li>以 PC 的值为地址从内存中获取一条指令并执行</li>
<li>PC+=4，goto 1</li>
</ol>
<p>而在上面的执行过程中，可能发生以下两种情况：</p>
<ol>
<li>指令执行出现错误，比如除零或缺页(同步异常)</li>
<li>外部设备触发中断(异步异常)</li>
</ol>
<p>上面的这两种情况，在 RISC-V 平台称为「异常」和「中断」。在检测到上面两种情况时，OS 会进入“trap”。</p>
<p><img src="./resource/trap%E6%B5%81%E7%A8%8B.png" alt="" /></p>
<p>具体的 trap 处理各阶段的工作，需要同学们根据老师上课教学内容，进行学习。</p>
<h2 id="trap-定义"><a class="header" href="#trap-定义">trap 定义</a></h2>
<ul>
<li>控制流(Control Flow)：</li>
</ul>
<ol>
<li>Branch</li>
<li>Jump</li>
</ol>
<ul>
<li>异常控制流(ExceptionalControlFlow，ECF)：</li>
</ul>
<ol>
<li>exception</li>
<li>interrupt</li>
</ol>
<p>在 Risc-V 下，ECF 统称为 trap。</p>
<p>对于 OS 来说，想要实现 trap，总共分为下面两步：</p>
<ol>
<li>实现对异常向量表的设置</li>
</ol>
<ul>
<li>CPU 上电后立即执行，这是系统初始化的主要工作之一</li>
<li>在开启中断和启动第一个应用之前执行完毕</li>
</ul>
<ol start="2">
<li>实现对不同异常(中断)的处理函数</li>
</ol>
<ul>
<li>处理应用程序出错的情况：如除零、缺页</li>
<li>一类特殊的同步异常：系统调用（我们会在下一节详细介绍），由应用程序来主动触发</li>
<li>处理来自外部设备的中断：如收取网络包、获取键盘输入等</li>
</ul>
<h2 id="在处理-trap-时使用到的寄存器"><a class="header" href="#在处理-trap-时使用到的寄存器">在处理 trap 时使用到的寄存器</a></h2>
<p><img src="./resource/trap%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="" /></p>
<p>相关寄存器的参数内容，请同学们参考 RISC-V 手册等参考资料进行自学。</p>
<h2 id="异常处理函数"><a class="header" href="#异常处理函数">异常处理函数</a></h2>
<p>异常处理函数在核心态，可以访问所有资源。处理器将异常类型存储在指定寄存器中（例如，<code>cause</code>），表明发生的是哪一种异常。异常处理函数根据异常类型执行不同逻辑。</p>
<p>当异常处理函数完成异常处理后，可以通过以下操作之一转移控制权：</p>
<ol>
<li>回到发生异常时正在执行的指令</li>
<li>回到发生异常时的下一条指令</li>
<li>结束当前进程</li>
</ol>
<h2 id="中断和异常的对比"><a class="header" href="#中断和异常的对比">中断和异常的对比</a></h2>
<p><img src="./resource/%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统调用"><a class="header" href="#系统调用">系统调用</a></h1>
<h2 id="本节目录-8"><a class="header" href="#本节目录-8">本节目录</a></h2>
<ul>
<li><a href="ch3-02.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a>
<ul>
<li><a href="ch3-02.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch3-02.html#%E7%89%B9%E6%9D%83%E7%BA%A7">特权级</a></li>
<li><a href="ch3-02.html#%E8%B7%9F%E8%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">跟踪系统调用</a></li>
<li><a href="ch3-02.html#%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC">参数与返回值</a></li>
<li><a href="ch3-02.html#%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD">提高性能</a></li>
</ul>
</li>
</ul>
<h2 id="特权级"><a class="header" href="#特权级">特权级</a></h2>
<p>系统调用需要特权级机制的支持。在 Risc-V 中，特权级如下表所示：
<img src="./resource/%E7%89%B9%E6%9D%83%E7%BA%A7.png" alt="" /></p>
<h2 id="跟踪系统调用"><a class="header" href="#跟踪系统调用">跟踪系统调用</a></h2>
<p>假设有代码：</p>
<pre><code class="language-c">int main() {
    write(1,"Hello world!\n",13);
    return 0;
}
</code></pre>
<p>我们可以通过下面命令跟踪系统调用：</p>
<pre><code class="language-bash">$ strace -o hello.out ./hello
</code></pre>
<h2 id="参数与返回值"><a class="header" href="#参数与返回值">参数与返回值</a></h2>
<p>系统调用的参数和返回值都是通过寄存器传递的。</p>
<ul>
<li>最多允许 8 个参数：a0-a7</li>
<li>a7 用于存放系统调用编号</li>
<li>调用者保存的寄存器必须在用户态保存</li>
<li>返回值存放于 a0 寄存器中</li>
</ul>
<p>但是，如果出现，系统调用的传参过多，无法直接使用寄存器放下，该怎么办呢？</p>
<p>朴素的解决方案是，通过将指针写入寄存器，然后由内核去访问指针指向的空间，但这可能会导致一系列的安全问题。因此，就需要验证其是否合法。对于此部分内容，需要同学们跟着老师学习，并且掌握 Linux 解决此问题的方案。</p>
<h2 id="提高性能"><a class="header" href="#提高性能">提高性能</a></h2>
<p>在对系统调用进行性能分析时，能够发现，主要的开销在于系统调用切换。因此，为了进一步提高性能，系统调用的时延不可忽略，尤其是调用非常频繁的那些，如 <code>gettimeofday()</code>。它的大部分时延都是由于 U-&gt;S/M 的模式切换带来的，如果没有模式切换，那么就不需要保存回复状态，就能够大幅降低系统调用的时延。</p>
<p>对于其，可以采用如下方式优化：
将 gettimeofday 的代码加载到一块与应用共享的内存页，这个页称为：vDSO(Virtual Dynamic Shared Object)，然后，将 Time 的值同样映射到用户态空间(只读)，但只有在内核态才能更新这个值。</p>
<p>不仅仅是 gettimeofday()，其它大部分的系统调用的大量时延，都是用来做状态的切换（保存和恢复状态、权限的切换）。还有一部分的时延，是因为（Cache pollution）。那么，是否有可能在不切换状态的情况下实现系统调用?</p>
<p>一个可行的解决方案是，引入了一个新的 syscall 机制：</p>
<ul>
<li>引入 system call page，由 user &amp; kernel 共享</li>
<li>User threads 可以将系统调用的请求 push 到 system call page</li>
<li><code>kernel threads</code>会从<code>system call page</code> poll <code>system call 请求</code></li>
</ul>
<p>性能提高的剩余内容，需要同学们跟随老师讲解学习。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第四章---第-3-课上---系统初始化"><a class="header" href="#第四章---第-3-课上---系统初始化">第四章 - 第 3 课(上) - 系统初始化</a></h1>
<h2 id="本章概述"><a class="header" href="#本章概述">本章概述</a></h2>
<p>本章将深入探讨计算机从完全关闭状态到完全加载操作系统和用户界面的完整初始化过程。我们将首先在第一节简要了解计算机的启动流程，包括加电自检（POST）和内核启动等关键步骤。</p>
<p>接着，我们将在第二章简要介绍 BIOS（基本输入输出系统）的作用、功能、物理位置以及基本结构，因为它是计算机启动过程中不可或缺的一部分。</p>
<p>随后，我们将主要介绍 EFI（可扩展固件接口）和 UEFI（统一可扩展固件接口）的介绍，这是现代计算机启动过程中逐渐取代 BIOS 的新技术。我们将探讨 EFI/UEFI 的简介、它们与 BIOS 的主要区别、其结构以及当前在业界的应用进展。</p>
<p>最后一节内容，我们将会基于 Linux 系统启动的过程，介绍剩下的阶段，包括 Grub、Init、RunLevel 等。同时，会简要介绍目前这些阶段的进展，以及未来可能的发展方向。</p>
<h2 id="本章目录-3"><a class="header" href="#本章目录-3">本章目录</a></h2>
<ul>
<li><a href="./ch4-01.html">计算机的启动</a></li>
<li><a href="./ch4-02.html">BIOS</a></li>
<li><a href="./ch4-03.html">EFI / UEFI</a></li>
<li><a href="./ch4-04.html">Grub、Init 与 RunLevel</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算机的启动"><a class="header" href="#计算机的启动">计算机的启动</a></h1>
<h2 id="本节目录-9"><a class="header" href="#本节目录-9">本节目录</a></h2>
<ul>
<li><a href="ch4-01.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8">计算机的启动</a>
<ul>
<li><a href="ch4-01.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch4-01.html#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A6%81">流程概要</a></li>
<li><a href="ch4-01.html#%E7%A1%AC%E4%BB%B6---%E5%8A%A0%E7%94%B5%E8%87%AA%E6%A3%80">硬件 - 加电自检</a></li>
<li><a href="ch4-01.html#%E8%BD%AF%E4%BB%B6---%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8">软件 - 内核启动</a></li>
</ul>
</li>
</ul>
<h2 id="流程概要"><a class="header" href="#流程概要">流程概要</a></h2>
<p><img src="./resource/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="" /></p>
<p>在计算机启动的过程中，BIOS 会首先进行加电自检，然后加载操作系统内核。计算机先进行硬件部分的加载，然后进行对于软件部分（即 OS）的加载，然后跳转到内核中执行。</p>
<h2 id="硬件---加电自检"><a class="header" href="#硬件---加电自检">硬件 - 加电自检</a></h2>
<p>在这一部分，我们会介绍加电自检。它的基本过程如下：</p>
<ol>
<li>初始化 BIOS</li>
<li>检查 CPU 寄存器检查 BIOS 代码的完整性</li>
<li>检查 DMA、timer、interrupt controller</li>
<li>检查系统内存</li>
<li>检查系统总线和外部设备</li>
<li>跳转到下一级 BIOS(如 VGA-BIOS)执行并返回</li>
<li>识别可以启动的设备(CD-ROM？USB？HDD？)</li>
</ol>
<p>但这一部分就涉及到了一个问题：由谁来执行这些检查？这一问题，我们将在下一节回答。</p>
<h2 id="软件---内核启动"><a class="header" href="#软件---内核启动">软件 - 内核启动</a></h2>
<p>在 BIOS 执行完加电自检之后，它会将控制权交给操作系统内核。此时，操作系统主要会进行两个任务：</p>
<ul>
<li>配置页表并开启虚拟内存机制，允许使用虚拟地址</li>
<li>配置异常向量表并打开中断，允许“双循环”</li>
</ul>
<p>同学们通过听课学习，应该要掌握：</p>
<ul>
<li>页表究竟该如何具体配置?</li>
<li>异常向量表如何配置?</li>
<li>开启地址翻译的前一行指令使用物理地址，开启后立即使用虚拟地址，前后如何衔接?</li>
<li>打开后，异常处理的指令流如何流动?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bios"><a class="header" href="#bios">BIOS</a></h1>
<h2 id="本节目录-10"><a class="header" href="#本节目录-10">本节目录</a></h2>
<ul>
<li><a href="ch4-02.html#bios">BIOS</a>
<ul>
<li><a href="ch4-02.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch4-02.html#bios-%E7%AE%80%E4%BB%8B">BIOS 简介</a></li>
<li><a href="ch4-02.html#bios-%E7%9A%84%E4%BD%9C%E7%94%A8">BIOS 的作用</a></li>
<li><a href="ch4-02.html#bios-%E7%9A%84%E5%8A%9F%E8%83%BD">BIOS 的功能</a></li>
<li><a href="ch4-02.html#bios-%E7%9A%84%E7%BB%93%E6%9E%84">BIOS 的结构</a>
<ul>
<li><a href="ch4-02.html#bios-%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">BIOS 的物理结构</a></li>
<li><a href="ch4-02.html#bios-%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%93%E6%9E%84">BIOS 代码的结构</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="bios-简介"><a class="header" href="#bios-简介">BIOS 简介</a></h2>
<p>BIOS：Basic Input/Output System，基本输入输出系统</p>
<p>BIOS 主要兴盛于 20 世纪 70 年代到 90 年代，它是一个固件（Firmware）程序，用于管理计算机硬件设备，并提供一些基本的输入输出功能。</p>
<h2 id="bios-的作用"><a class="header" href="#bios-的作用">BIOS 的作用</a></h2>
<ul>
<li>在计算机开机时对系统各组件进行检查</li>
<li>加载引导程序或操作系统</li>
<li>向操作系统提供系统配置信息</li>
<li>向操作系统提供硬件访问接口，向操作系统隐感硬件的变化</li>
<li>现代操作系统会忽略 BIOS 提供的抽象层并直接访问硬件</li>
</ul>
<h2 id="bios-的功能"><a class="header" href="#bios-的功能">BIOS 的功能</a></h2>
<p>BIOS 中主要存放以下程序段：</p>
<ol>
<li>自诊断程序：<br />
通过读取 CMOSRAM 中的内容，识别硬件配置，并对其进行自检和初始化。</li>
<li>CMOS 设置程序：<br />
引导过程中，用特殊热键启动，进行设置后，存入 CMOS RAM 中。</li>
<li>系统自检装载程序：<br />
在自检成功后，将磁盘 0 磁道 0 扇区上的引导程序装入内存，让其运行以装入系统。</li>
<li>主要 IO 设备的驱动程序和中断服务</li>
</ol>
<h2 id="bios-的结构"><a class="header" href="#bios-的结构">BIOS 的结构</a></h2>
<h3 id="bios-的物理结构"><a class="header" href="#bios-的物理结构">BIOS 的物理结构</a></h3>
<p>BIOS 的物理结构主要体现在其存储方式上。BIOS 代码通常存储在一个只读存储器（Read-Only Memory，ROM）芯片中，这种芯片能够在计算机断电后仍然保留数据，因此，计算机每次启动时都能执行相同的 BIOS 代码。这种存储方式保证了 BIOS 的稳定性和可靠性。</p>
<h3 id="bios-代码的结构"><a class="header" href="#bios-代码的结构">BIOS 代码的结构</a></h3>
<p>BIOS 代码的结构主要指的是 BIOS 程序的组织方式。BIOS 程序通常包括以下几个部分：</p>
<ol>
<li>启动自检程序（POST）：计算机启动时首先执行的是自检程序，它负责检测计算机硬件设备是否正常，包括内存检测、显卡检测、硬盘检测等。</li>
<li>设置程序：如果自检通过，BIOS 会执行设置程序，允许用户配置计算机的一些基本参数，如启动顺序、内存速度等。</li>
<li>启动加载程序：设置完成后，BIOS 会根据用户设定的启动顺序，从硬盘、光驱或其他存储设备中加载引导记录（Boot Record），并将控制权转交给引导记录中的操作系统。</li>
<li>中断服务程序：BIOS 还提供了一系列的中断服务程序（Interrupt Service Routines，ISRs），这些程序可以在操作系统运行期间被调用，用于处理硬件设备的输入输出请求。</li>
<li>CMOS 配置：BIOS 使用 CMOS（互补金属氧化物半导体）电路来存储计算机的配置信息。CMOS 是一种低功耗的静态随机存储器（SRAM），它由一个小型电池供电，即使在计算机关闭的情况下也能保持数据不丢失。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="efi--uefi"><a class="header" href="#efi--uefi">EFI / UEFI</a></h1>
<h2 id="本节目录-11"><a class="header" href="#本节目录-11">本节目录</a></h2>
<ul>
<li><a href="ch4-03.html#efi--uefi">EFI / UEFI</a>
<ul>
<li><a href="ch4-03.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch4-03.html#efi--uefi-%E7%AE%80%E4%BB%8B">EFI / UEFI 简介</a></li>
<li><a href="ch4-03.html#efi--uefi-%E4%B8%8E-bios-%E7%9A%84%E5%8C%BA%E5%88%AB">EFI / UEFI 与 BIOS 的区别</a></li>
<li><a href="ch4-03.html#efi--uefi-%E7%9A%84%E7%BB%93%E6%9E%84">EFI / UEFI 的结构</a></li>
<li><a href="ch4-03.html#efi--uefi-%E5%BD%93%E5%89%8D%E8%BF%9B%E5%B1%95">EFI / UEFI 当前进展</a></li>
</ul>
</li>
</ul>
<h2 id="efi--uefi-简介"><a class="header" href="#efi--uefi-简介">EFI / UEFI 简介</a></h2>
<p>在上一节提到，BIOS 主要流行于 1970s 到 1990s，因为计算机硬件设备种类繁多，而 BIOS 只能识别硬件设备，无法识别软件设备，而不再能满足计算机硬件设备日益复杂的需求。因此，1990s 后，出现了 EFI / UEFI。</p>
<p>Intel 提出了，使用 EFI(Extensible Firmware Interface)取代 BlOS interface 。</p>
<p>2005 年，Intel 再次提出用 UEFI(Unified Extensible Firmware Interface)取代 EFI。</p>
<p>下图展示了 EFI 的架构位置：</p>
<p><img src="./resource/EFI.png" alt="" /></p>
<h2 id="efi--uefi-与-bios-的区别"><a class="header" href="#efi--uefi-与-bios-的区别">EFI / UEFI 与 BIOS 的区别</a></h2>
<p>首先，对于编程语言来说，BIOS 主要使用汇编语言，而 EFI 主要使用 C 语言。EFI 是用模块化的思想，借助动态链接的形式构建的系统，较 BIOS 而言更易于实现，容错和纠错特性更强，缩短了研发时间。</p>
<p>其次，对于 BIOS 具有的三大任务：</p>
<ol>
<li>初始化硬件</li>
<li>提供硬件的软件抽象</li>
<li>启动操作系统</li>
</ol>
<p>UEFI 具有三大优势：</p>
<ol>
<li>标准接口</li>
<li>开放统一</li>
<li>开源</li>
</ol>
<p>同时，EFI 运行于 32 位或 64 位模式，突破了传统 16 位代码的寻址能力。而 BIOS 的硬件服务程序都以 16 位代码的形式存在，这就给运行于增强模式的操作系统访问其服务造成了困难。</p>
<p>而且，EFI 系统下的驱动并不是由可以直接运行在 CPU 上的代码组成的，而是用 EFIByte Code 编写而成的。这是一组专用于 EFI 驱动的虚拟机器语言，必须在 EFI 驱动运行环境下被解释运行。这就保证了充分的向下兼容性。</p>
<p>因此，EFI 和 UEFI 才能够被广泛接受。</p>
<h2 id="efi--uefi-的结构"><a class="header" href="#efi--uefi-的结构">EFI / UEFI 的结构</a></h2>
<p>更加具体的 EFI 的架构位置如下图所示：
<img src="./resource/EFI%E7%BB%93%E6%9E%84.png" alt="" /></p>
<h2 id="efi--uefi-当前进展"><a class="header" href="#efi--uefi-当前进展">EFI / UEFI 当前进展</a></h2>
<p>当前，对于 UEFI 应用的一个典型例子是 LinuxBoot：
<img src="./resource/EFI%E5%8F%91%E5%B1%95.png" alt="" /></p>
<p>感兴趣的同学们可以参考：</p>
<ul>
<li><a href="https://www.kernel.org/doc/html/v6.9-rc7/arch/loongarch/booting.html">LinuxBoot</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grubinit-与-runlevel"><a class="header" href="#grubinit-与-runlevel">Grub、Init 与 RunLevel</a></h1>
<h2 id="本章目录-4"><a class="header" href="#本章目录-4">本章目录</a></h2>
<ul>
<li>Grub 简介</li>
<li>Init 简介</li>
<li>RunLevel 简介</li>
<li>目前进展（init-&gt;systemd）</li>
</ul>
<h2 id="linux-启动流程"><a class="header" href="#linux-启动流程">Linux 启动流程</a></h2>
<p>在 Linux 系统下，启动流程如下：</p>
<p><img src="./resource/Linux%E5%90%AF%E5%8A%A8.png" alt="" /></p>
<h2 id="引导程序---bootloader"><a class="header" href="#引导程序---bootloader">引导程序 - bootloader</a></h2>
<p>bootloader，即引导程序，是开机时，引导操作系统启动的程序。</p>
<p>BIOS 在完成硬件检测和资源分配后，将硬盘 MBR 中的 bootloader 读到系统的 RAM 中，然后将控制权交给 bootloader。</p>
<p>bootoader 的主要任务就是将操作系统内核从硬盘加载到 RAM 中，然后跳转到内核的入口点去执行，即启动操作系统。</p>
<p>常见的 bootloader 有：Grub，isolinux，uboot，openSBl，ntldr(用于启动 Windows 系统)，<strong>Linuxboot</strong>等。</p>
<p>操作系统需要被加载到内存中正确的位置，且需要程序为操作系统提供启动参数，以实现定制化启动，所以需要 bootloader。</p>
<h2 id="grub-简介"><a class="header" href="#grub-简介">Grub 简介</a></h2>
<p>Grub 是 Linux 上最常用的 bootloader。它是一个来自 GNU 项目的启动引导程序。GRUB 允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统，也就是说，我们可以通过 Grub，使用链式引导来引导 Windows 系统。</p>
<p>它支持所有的 Linux 文件系统，也支持 Windows 的 FAT 和 NTFS 文件系统，也支持图形界面，可定制启动菜单和背景图片，支持鼠标。同时，它拥有丰富的终端命令，用户可以查看硬盘分区的细节，修改分区设置，临时重新映射磁盘顺序，从任何用户定义的配置文件启动。</p>
<p>感兴趣的同学们可以去自行深入了解 Grub。</p>
<h2 id="init-简介"><a class="header" href="#init-简介">Init 简介</a></h2>
<p>初始化（Init）程序负责操作系统的初始化操作，它基于<code>/etc/inittab</code>（定义了系统默认运行级别）设定的动作来执行脚本。以下是初始化流程的主要步骤：</p>
<ol>
<li>
<p><strong>执行<code>/etc/rc.d/rc.sysinit</code>脚本</strong></p>
<ul>
<li>真正的 OS 初始化脚本。</li>
</ul>
</li>
<li>
<p><strong>激活 udev 和 SELinux</strong></p>
<ul>
<li>udev 管理设备节点和它们的符号链接。</li>
<li>SELinux（如果启用）是 Linux 的一个安全模块。</li>
</ul>
</li>
<li>
<p><strong>设定内核参数</strong></p>
<ul>
<li>根据<code>/etc/sysctl.conf</code>文件来设定内核参数。</li>
</ul>
</li>
<li>
<p><strong>设定系统时钟</strong></p>
<ul>
<li>确保系统时间正确。</li>
</ul>
</li>
<li>
<p><strong>装载硬盘映射</strong></p>
<ul>
<li>加载硬盘相关的映射或配置。</li>
</ul>
</li>
<li>
<p><strong>启用交换分区</strong></p>
<ul>
<li>激活交换空间以扩展系统内存。</li>
</ul>
</li>
<li>
<p><strong>设置主机名</strong></p>
<ul>
<li>设置系统在网络中的名称。</li>
</ul>
</li>
<li>
<p><strong>根文件系统检测与重新挂载</strong></p>
<ul>
<li>以读写方式重新挂载根文件系统，并在挂载前进行检测。</li>
</ul>
</li>
<li>
<p><strong>激活 RAID 和 LVM 设备</strong></p>
<ul>
<li>如果配置有 RAID 或 LVM，则激活这些设备。</li>
</ul>
</li>
<li>
<p><strong>启用磁盘配额</strong></p>
<ul>
<li>根据配置，启用文件系统上的磁盘配额。</li>
</ul>
</li>
<li>
<p><strong>检查并挂载其他文件系统</strong></p>
<ul>
<li>根据<code>/etc/fstab</code>文件，检查并挂载其他文件系统。</li>
</ul>
</li>
<li>
<p><strong>清理过期的锁和 PID 文件</strong></p>
<ul>
<li>清除在系统启动过程中可能不再需要的锁文件和 PID 文件。</li>
</ul>
</li>
<li>
<p><strong>执行对应启动级别的脚本</strong></p>
<ul>
<li>根据配置的启动级别，执行对应目录（如<code>/etc/rcX.d/</code>，其中<code>X</code>是运行级别）下的脚本。</li>
</ul>
</li>
<li>
<p><strong>执行<code>/etc/rc.d/rc.local</code>脚本</strong></p>
<ul>
<li>这是系统初始化过程中的最后一个通用脚本，用户可以在这里添加自定义的启动命令。</li>
</ul>
</li>
</ol>
<p><strong>系统启动完成</strong></p>
<ul>
<li>执行完以上步骤后，系统启动完成，等待用户登录或其他进一步的操作。</li>
</ul>
<h2 id="runlevel-简介"><a class="header" href="#runlevel-简介">RunLevel 简介</a></h2>
<p>runlevel，即运行级别，是 Linux 系统中的一个概念。
Linux 的启动级别定义了系统启动时应该运行哪些服务。</p>
<p>运行级别有如下的分类：</p>
<ul>
<li><strong>0</strong>: 关机模式</li>
<li><strong>1</strong>: 单一用户模式（直接以管理员身份进入）</li>
<li><strong>2</strong>: 多用户模式（无网络）</li>
<li><strong>3</strong>: 多用户模式（命令行）</li>
<li><strong>4</strong>: 保留（通常不使用）</li>
<li><strong>5</strong>: 多用户模式（图形界面）</li>
<li><strong>6</strong>: 重启</li>
</ul>
<p>运行级别对应的脚本目录如下所示：</p>
<ul>
<li><strong>Run level 0</strong>: <code>/etc/rc.d/rc0.d/</code></li>
<li><strong>Run level 1</strong>: <code>/etc/rc.d/rc1.d/</code></li>
<li><strong>Run level 2</strong>: <code>/etc/rc.d/rc2.d/</code></li>
<li><strong>Run level 3</strong>: <code>/etc/rc.d/rc3.d/</code></li>
<li><strong>Run level 4</strong>: <code>/etc/rc.d/rc4.d/</code></li>
<li><strong>Run level 5</strong>: <code>/etc/rc.d/rc5.d/</code></li>
<li><strong>Run level 6</strong>: <code>/etc/rc.d/rc6.d/</code></li>
</ul>
<p>在上述目录中，脚本的命名遵循以下规则：</p>
<ul>
<li><strong>K</strong> 开头的文件：表示在启动时需要关闭的服务。</li>
<li><strong>S</strong> 开头的文件：表示在启动时需要启动的服务。</li>
</ul>
<h2 id="目前进展init-systemd"><a class="header" href="#目前进展init-systemd">目前进展（init-&gt;systemd）</a></h2>
<p>对于 Init 阶段来说，它具有一些问题：</p>
<ul>
<li>启动时间长。ini 进程是串行启动，只有前一个进程启动完才会启动下一个进程。</li>
<li>启动脚本复杂。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li>
</ul>
<p>为了解决上述问题，Linux 系统引入了 Systemd 系统。感兴趣的同学们可以自行了解。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第五章---第-3-课下---risc-v-的初始化"><a class="header" href="#第五章---第-3-课下---risc-v-的初始化">第五章 - 第 3 课(下) - Risc-V 的初始化</a></h1>
<h2 id="本章概述-1"><a class="header" href="#本章概述-1">本章概述</a></h2>
<p>在上一章内容里，我们介绍了系统的初始化流程，并且以 Linux 系统为例，介绍了 Linux 系统启动的各个阶段。本章则详细介绍了 Risc-V 架构下的系统初始化过程，包括从启动流程、链接脚本、页表和异常向量的设置等内容。</p>
<p>在第一节，我们会讲一下 Risc-V 设备的一般的启动流程。我们会介绍到 bootloader 和链接脚本（Linker Script），它们扮演着重要的角色。链接脚本定义了如何将程序的不同部分（如代码、数据和栈）映射到内存中的不同位置，也是我们编写内核过程中需要掌握的终点。</p>
<p>在第二节，我们延续上一章介绍过的页表和异常向量的初始化过程，只需要同学们稍作了解，具体的细节会在下一阶段详细介绍。</p>
<p>在第三节，我们描述了从系统上电到操作系统开始运行的过程。我们将介绍几个重要的引导加载程序，即 OpenSBI 和 U-Boot，它们在系统启动过程中扮演着桥梁的角色，负责初始化硬件、加载操作系统镜像等任务。此外，我们还将探讨 DeviceTree 和 UEFI 在 Risc-V 系统初始化中的作用，以及它们之间的对比和特点。</p>
<h2 id="本章目录-5"><a class="header" href="#本章目录-5">本章目录</a></h2>
<ul>
<li><a href="./ch5-01.html">启动流程和链接脚本</a></li>
<li><a href="./ch5-02.html">初始化</a></li>
<li><a href="./ch5-03.html">Risc-V 设备从上电到运行</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="启动流程和链接脚本"><a class="header" href="#启动流程和链接脚本">启动流程和链接脚本</a></h1>
<h2 id="本节目录-12"><a class="header" href="#本节目录-12">本节目录</a></h2>
<ul>
<li><a href="ch5-01.html#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC">启动流程和链接脚本</a>
<ul>
<li><a href="ch5-01.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch5-01.html#%E4%B8%80%E8%88%AC%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">一般启动流程</a></li>
<li><a href="ch5-01.html#%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC">链接脚本</a></li>
<li><a href="ch5-01.html#%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81">内核代码</a></li>
</ul>
</li>
</ul>
<h2 id="一般启动流程"><a class="header" href="#一般启动流程">一般启动流程</a></h2>
<p>对于 Risc-V 开发板，我们仍然以 Linux 系统为例，其一般的启动流程如下：</p>
<ul>
<li>板子上电后，CPU 从固定地址运行 ROM 中的代码</li>
<li>ROM 包含简单的设备驱动，从 fash 或者 SD 卡中加载 bootloader</li>
<li>再由 bootloader 加载内核、initramfs 等到内存，跳转到 Linux 内核启动</li>
</ul>
<p>在一个基于全志 D1 硬件平台的启动流程内，主要涉及到 SPL（Secondary Program Loader）、U-Boot 和 Linux 操作系统。在这个流程中，它们的角色和各自的加载地址如下：</p>
<p>SPL，二级程序加载器，通常位于设备的 ROM（只读存储器）中。它是最先被执行的代码，负责执行一些基本的硬件初始化和准备工作。SPL 的任务主要就是将下一级的引导加载器（如 U-Boot）从存储设备加载到 RAM 中。</p>
<p>U-Boot，一个开源的引导加载器，广泛用于嵌入式系统。在这个流程中，U-Boot 是由 SPL 从存储设备加载到 RAM 中，并从物理地址 <code>0x4a00_0000</code> 开始执行。U-Boot 会将 Linux 内核镜像从存储设备加载到 RAM 中的某个位置，并设置必要的启动参数，然后将控制权传递给 Linux 内核。</p>
<p>Linux 是最终要执行的操作系统。在这个流程中，Linux 内核从物理地址 <code>0x4200_0000</code> 开始执行。</p>
<p>感兴趣的同学们可以通过以下资料获取相关内容：
<a href="https://linux-sunxi.org/Allwinner_Nezha">参考资料</a></p>
<h2 id="链接脚本"><a class="header" href="#链接脚本">链接脚本</a></h2>
<p>链接脚本（Linker Script）是用于定义如何将程序的不同部分（如代码、数据、栈等）映射到内存中的文件。在嵌入式系统和操作系统开发中，链接脚本是一个非常重要的文件，因为它决定了程序在内存中的布局和大小。</p>
<p>在 Risc-V 系统中，链接脚本通常使用特定的语法来描述内存布局和符号地址。它定义了程序的各个段（如代码段、数据段、BSS 段等）的起始地址和大小，以及它们之间的相对位置。链接器（Linker）在编译过程中使用链接脚本来确定程序的最终内存布局，并生成可执行文件或镜像文件。</p>
<p>对于链接脚本来说，同学们需要了解程序的编译过程，具体要了解到代码段的更细的划分、数据段的更细的划分，需要同学们进行自学，可以在下面资料进行参考：<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html#id6">参考资料</a>。</p>
<h2 id="内核代码"><a class="header" href="#内核代码">内核代码</a></h2>
<p>内核代码是操作系统的核心部分，负责管理硬件资源、提供系统服务以及运行用户程序。在 Risc-V 系统中，内核代码通常使用 C 语言（或汇编语言）编写，并遵循特定的编程规范和接口标准。</p>
<p>对于内核代码，其二进制从.head.text 开始，剩余内容，请同学们跟着老师的课程进行学习，主要会讲解到 Linux 下的地址映射、内核运行的代码顺序等知识点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初始化"><a class="header" href="#初始化">初始化</a></h1>
<h2 id="本节目录-13"><a class="header" href="#本节目录-13">本节目录</a></h2>
<ul>
<li><a href="ch5-02.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>
<ul>
<li><a href="ch5-02.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch5-02.html#%E9%A1%B5%E8%A1%A8%E5%92%8C-mmu">页表和 MMU</a></li>
<li><a href="ch5-02.html#risc-v-%E9%A1%B5%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96">Risc-V 页表初始化</a></li>
<li><a href="ch5-02.html#%E5%90%AF%E7%94%A8-mmu-%E5%89%8D%E5%90%8E">启用 MMU 前后</a></li>
<li><a href="ch5-02.html#risc-v-%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96">Risc-V 异常向量初始化</a></li>
<li><a href="ch5-02.html#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
</ul>
<h2 id="页表和-mmu"><a class="header" href="#页表和-mmu">页表和 MMU</a></h2>
<ul>
<li>Linux 内核运行需要 MMU 启用</li>
<li>内核刚开始运行，MMU 未启用</li>
<li>需要写好一个页表将内核映射到高地址，然后启用 MMU</li>
</ul>
<h2 id="risc-v-页表初始化"><a class="header" href="#risc-v-页表初始化">Risc-V 页表初始化</a></h2>
<p><code>setup_vm</code> 初始化启动用到的两个页表：</p>
<ul>
<li><code>trampoline_pg_dir</code>：启用 MMU 前后所用，映射启用 MMU 的代码到高地址</li>
<li><code>early_pg_dir</code>：内核最初启动的时候所用，映射整个内核到高地址</li>
</ul>
<p>具体的实现逻辑，请自学或参照老师的课程进行学习。</p>
<h2 id="启用-mmu-前后"><a class="header" href="#启用-mmu-前后">启用 MMU 前后</a></h2>
<p><code>relocate_enable_mmu</code> 用于启用 MMU，并跳转到高地址继续执行：</p>
<ul>
<li>使用 <code>trampoline_pg_dir</code> 衔接</li>
<li>启用 MMU</li>
<li>返回后 <code>pc</code> 在高地址</li>
</ul>
<p>这一部分涉及到一个问题：内核启动时从 <code>0x4020_0000</code> 开始，而内核代码需要在 <code>0xFFFFFFFF80000000</code> 运行。如何配置 MMU 来完成这个切换?</p>
<p>通过配置 MMU 来完成这个切换的方法是：</p>
<p>直接设置返回地址加上偏移量的结果，将其变成高地址，这样在返回后就能正确运行了。</p>
<h2 id="risc-v-异常向量初始化"><a class="header" href="#risc-v-异常向量初始化">Risc-V 异常向量初始化</a></h2>
<p>通过 <code>setup_trap_vector</code> 初始化异常向量：</p>
<ul>
<li>RISC-V Linux 使用一个统一的入口点 handle_exception 来处理异常和中断</li>
<li>scratch=0 表示异常从内核态发生</li>
<li>sscratch ≠ 0 时，它指向一个 task_struct 结构体，表示异常从用户态发生</li>
<li>RISC-V 的系统调用也被视为一种异常处理</li>
</ul>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>在 Risc-V 初始化过程中，主要完成以下任务：</p>
<ul>
<li>设置初始化时的简单页表 early_pg_dir，并开启虚拟内存机制（MMU）</li>
<li>设置异常向量 stvec 指向 handle_exception 函数
<ul>
<li>在处理异常之前保存进程上下文</li>
<li>在返回进程之前恢复其上下文</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="risc-v-设备从上电到运行"><a class="header" href="#risc-v-设备从上电到运行">Risc-V 设备从上电到运行</a></h1>
<h2 id="本节目录-14"><a class="header" href="#本节目录-14">本节目录</a></h2>
<ul>
<li><a href="ch5-03.html#risc-v-%E8%AE%BE%E5%A4%87%E4%BB%8E%E4%B8%8A%E7%94%B5%E5%88%B0%E8%BF%90%E8%A1%8C">Risc-V 设备从上电到运行</a>
<ul>
<li><a href="ch5-03.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch5-03.html#%E6%B5%81%E7%A8%8Bopensbi-%E5%92%8C-u-boot">流程（OpenSbi 和 U-boot）</a></li>
<li><a href="ch5-03.html#devicetree">DeviceTree</a></li>
<li><a href="ch5-03.html#risc-v-uefi">Risc-V UEFI</a></li>
<li><a href="ch5-03.html#%E5%AF%B9%E6%AF%94">对比</a></li>
<li><a href="ch5-03.html#risc-v-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%90%AF%E5%8A%A8%E7%9A%84%E7%89%B9%E7%82%B9">Risc-V 嵌入式设备启动的特点</a></li>
</ul>
</li>
</ul>
<h2 id="流程opensbi-和-u-boot"><a class="header" href="#流程opensbi-和-u-boot">流程（OpenSbi 和 U-boot）</a></h2>
<p>这一部分，我们以常用的基于 U-Boot 和 OpenSBl 的启动流程为例。</p>
<p>通过上一章的学习，我们知道，在上电之后，会从 ROM 中开始执行代码，
在 SoC(System on Chip)架构下， 芯片内部包含一块 ROM，保存了一些简单的驱动，同时会从 SD 卡或 fash 加载 U-Boot SPL 到一块小内存中(单独的 SRAM 或 L2cache-as-RAMM)。然后会又 U-Boot SPL 进行最早的初始化，主要是初始化 DDR 内存、时钟等最重要的设备，并且从 SD 卡加载 OpenSBI 和 U-Boot 本体到 DDR 内存，然后跳转到 OpenSBI 运行。</p>
<p>对于 OpenSBI 和 U-Boot 来说，它们执行下面工作：
OpenSBI：</p>
<ul>
<li>初始化 IPI 和时钟设备</li>
<li>初始化自身准备好提供 SBI 服务</li>
<li>切换到 Supervisor mode，跳转到 U-Boot</li>
</ul>
<p>U-Boot：</p>
<ul>
<li>从预先配置的启动设备加载内核到内存(来源可以是 SD 卡、NVMe、网络……)</li>
<li>跳转到内核入口点</li>
</ul>
<p>之后，操作系统就能够开始运行了。</p>
<h2 id="devicetree"><a class="header" href="#devicetree">DeviceTree</a></h2>
<p>那么，软件如何获知机器上有哪些功能和设备呢？</p>
<p>对于 ROM 来说，其内部的代码比较固定，可以在直接代码里对照硬件资源编写。但对于通用的操作系统，例如 Linux 内核，如何在各种机器上都可以运行?</p>
<p>对于嵌入式设备来说，解决获知设备问题的方法是 Devicetree。</p>
<ul>
<li>文本格式(Devicetree source,DTS)和二进制格式(Flattened devicetree,FDT 或 DTB)</li>
<li>包含设备信息、MMIO 地址、中断连接方式、时钟复位电源连接方式等信息</li>
<li>与内核同时加载到内存中，跳转到各软件入口点时传入地址</li>
<li>惯例:a0 是当前核心的 hartid，a1 是内存中 FDT 的物理地址</li>
<li>(U-Boot 和 OpenSBl 为了方便及复用 devicetree 已经完成的工作，也用 FDT 获得硬件配置)</li>
</ul>
<h2 id="risc-v-uefi"><a class="header" href="#risc-v-uefi">Risc-V UEFI</a></h2>
<p>RISC-V 机器固件也可以提供 UEFI 接口</p>
<ul>
<li>提供 PCle 控制器的驱动，可以以通用方式访问 PCle 设备</li>
<li>提供 PCle Option ROM 支持，在早期启动时就可以用上外部设备的功能(显卡的显示功能、网卡的网络启动功能.)</li>
</ul>
<p>操作系统通过 ACPI 获知硬件信息</p>
<ul>
<li>比 devicetree 提供更多的信息，还提供更多接口，如通用的 PCle 设备访问，热插拔通知，电源管理接口</li>
<li>当然也比 devicetree 复杂</li>
<li>(在比较简单的设备上 UEFI 也可以不提供 ACPI 而提供 devicetree)</li>
</ul>
<h2 id="对比"><a class="header" href="#对比">对比</a></h2>
<p>定制化的主板(常见的 RISC-V 开发板，通常不再扩展其他设备)</p>
<ul>
<li>需要初始化具体主板相关硬件如 GPIO 和内存等</li>
<li>从 devicetree 获知有哪些设备</li>
<li>操作系统中需要很多设备相关的驱动</li>
</ul>
<p>通用的主板(常见如 PC，通常需要再插入其他设备)</p>
<ul>
<li>系统配置情况在开机时候是不知道的</li>
<li>需要探测(Probe)、Training(内存和 PCle)和枚举(PCle 等等即插即用设备)</li>
<li>UEFI/ACPI 提供了整个主板、包括主板上外插的设备的软件抽象，通过定义的接口把这些信息传递给 OS，使 OS 不改而能够适配到所有机型和硬件</li>
</ul>
<h2 id="risc-v-嵌入式设备启动的特点"><a class="header" href="#risc-v-嵌入式设备启动的特点">Risc-V 嵌入式设备启动的特点</a></h2>
<p>通常与设备强相关</p>
<ul>
<li>ROM 通常是闭源的</li>
<li>早期启动流程通常是厂商提供的代码，例如 DDR 内存控制器的初始化代码，即使有 C 源码，一般也是无法理解其中很多魔法数字</li>
</ul>
<p>缺点：对可插拔外设的兼容性</p>
<ul>
<li>如 RISC-V 嵌入式设备支持 PCle 外设，需要操作系统内核包含具体硬件上的 PCle 控制器驱动</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第六章---题目分析1---9"><a class="header" href="#第六章---题目分析1---9">第六章 - 题目分析[1 - 9]</a></h1>
<h2 id="本章概要-3"><a class="header" href="#本章概要-3">本章概要</a></h2>
<p>本章主要进行的习题知识点范围如下：</p>
<ul>
<li>实验代码框架讲解</li>
<li>MakeFile 脚本分析</li>
<li>ld 脚本分析</li>
</ul>
<p>对于 MakeFile 文档，我们将会进行 5 道练习题，内容分别为：</p>
<ol>
<li>编写第一份 MakeFile</li>
<li>编写用于测试的 MakeFile</li>
<li>使用 Makefile 静态链接程序</li>
<li>使用 Makefile 构建第一个静态链接库</li>
<li>使用 Makefile 构建第一个动态链接库</li>
</ol>
<p>在 MakeFile 题目中，涉及到了 gcc 编译的一部分内容和一些 MakeFile 的基础知识点。</p>
<p>对于 ld 脚本，我们将会进行 4 道练习题，内容分别是：</p>
<ol>
<li>编写一个简单的 ld 文件并指定内存区域。</li>
<li>编写一个简单的 ld 文件并指定 text 起始地址。</li>
<li>编写一个简单的 ld 文件并指定自定义 symbol。</li>
<li>编写一个简单的 ld 文件并指定自定义 section。</li>
</ol>
<p>这部分内容要求同学们对于 ld 脚本的结构有一定的了解，并且要了解大致的编译原理。</p>
<h2 id="本章目录-6"><a class="header" href="#本章目录-6">本章目录</a></h2>
<ul>
<li><a href="./ch6-01.html">实验代码框架讲解</a></li>
<li><a href="./ch6-01.html">实验代码框架讲解</a></li>
<li><a href="./ch6-02.html">第一题 - MakeFile - 编写第一份 MakeFile</a></li>
<li><a href="./ch6-03.html">第二题 - MakeFile - 编写用于测试的 MakeFile</a></li>
<li><a href="./ch6-04.html">第三题 - MakeFile - 静态链接程序</a></li>
<li><a href="./ch6-05.html">第四题 - MakeFile - 构建第一个静态链接库</a></li>
<li><a href="./ch6-06.html">第五题 - MakeFile - 构建第一个动态链接库</a></li>
<li><a href="./ch6-07.html">第六题 - ld 脚本 - 指定内存区域</a></li>
<li><a href="./ch6-08.html">第七题 - ld 脚本 - 指定 text 起始地址</a></li>
<li><a href="./ch6-09.html">第八题 - ld 脚本 - 指定自定义 symbol</a></li>
<li><a href="./ch6-10.html">第九题 - ld 脚本 - 指定自定义 section</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验代码框架讲解"><a class="header" href="#实验代码框架讲解">实验代码框架讲解</a></h1>
<h2 id="本节目录-15"><a class="header" href="#本节目录-15">本节目录</a></h2>
<ul>
<li><a href="ch6-01.html#%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3">实验代码框架讲解</a>
<ul>
<li><a href="ch6-01.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-01.html#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">项目结构</a></li>
<li><a href="ch6-01.html#makefile-%E5%86%85%E5%AE%B9">Makefile 内容</a></li>
<li><a href="ch6-01.html#%E4%BD%BF%E7%94%A8-makefile-%E8%BF%9B%E8%A1%8C%E5%AE%9E%E9%AA%8C">使用 makefile 进行实验</a></li>
</ul>
</li>
</ul>
<h2 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h2>
<pre><code class="language-bash">.
├── exercises //所有习题都在此文件夹下
├── LICENSE
├── Makefile
├── README.en.md
├── README.md
└── test //所有测例都在此文件夹下
</code></pre>
<ul>
<li><strong>exercises</strong>：这个文件夹包含了所有的习题代码。每个习题可以作为一个子文件夹，其中包含习题的源代码、数据文件和任何相关的资源。</li>
<li><strong>LICENSE</strong>：项目的许可证文件，定义了项目的使用、修改和分发的法律条款。</li>
<li><strong>Makefile</strong>：一个自动化构建脚本，用于编译、测试和清理项目。通过运行 <code>make</code> 命令，可以执行 Makefile 中定义的任务。</li>
<li><strong>test</strong>：这个文件夹包含了所有的测试用例。每个测试用例可以作为一个子文件夹或文件，用于验证习题代码的正确性。</li>
</ul>
<h2 id="makefile-内容"><a class="header" href="#makefile-内容">Makefile 内容</a></h2>
<p>实验框架的 Makefile：</p>
<pre><code class="language-Makefile"># Makefile variables for directory structure and tools
AUX_DIR     := aux             # Auxiliary directory
BUILD_DIR   := build           # Build output directory
SRC_DIR     := src             # Source code directory
RESULT_DIR  := result          # Test result directory
TEST_DIR    := test            # Directory containing test scripts

# Compiler settings
CC ?= gcc                       # Default compiler

# Compiler flags
CFLAGS = -std=c11 -Wall -Wextra -Wpedantic -Werror -g  # C compiler flags
LDFLAGS = -Wl,--as-needed -Wl,--no-undefined          # Linker flags

# Find all exercise directories under SRC_DIR
EXERCISES := $(shell find $(SRC_DIR) -type d -name 'exercise-*' -exec basename {} \;)

# Default target: build all exercises
all: $(EXERCISES)

# Build each exercise directory
$(EXERCISES):
    @mkdir -p $(abspath $(BUILD_DIR))/$(notdir $@)
    $(MAKE) -C $(SRC_DIR)/$@ OUTPUT_DIR=$(abspath $(BUILD_DIR))/$(notdir $@) || true

# Test target: run tests for all exercises
test: $(RESULT_DIR) $(EXERCISES:%=test-%) report generate_json_report

# Test each exercise
test-%: $(BUILD_DIR)/%
    @mkdir -p $(RESULT_DIR)/$*
    @echo "Running tests for $*"
    @$(TEST_DIR)/$*/test.sh $(BUILD_DIR)/$*/$* &amp;&amp; touch $(RESULT_DIR)/$*/$*.pass || touch $(RESULT_DIR)/$*/$*.fail

# Create build directory if it doesn't exist
$(BUILD_DIR):
    @mkdir -p $(BUILD_DIR)

# Create result directory if it doesn't exist
$(RESULT_DIR):
    @mkdir -p $(RESULT_DIR)

# Generate a human-readable test report
report:
    @echo "Generating test report..."
    @total=$$(find $(RESULT_DIR) -type f -name '*.pass' -o -name '*.fail' | wc -l); \
    success=$$(find $(RESULT_DIR) -type f -name '*.pass' | wc -l); \
    failed=$$(find $(RESULT_DIR) -type f -name '*.fail' | wc -l); \
    echo "Total tests: $$total"; \
    echo "Success: $$success"; \
    echo "Failed: $$failed"; \
    echo "Success tests:"; \
    find $(RESULT_DIR) -type f -name '*.pass' -exec basename {} .pass \; | sed 's/^/  /'; \
    echo "Failed tests:"; \
    find $(RESULT_DIR) -type f -name '*.fail' -exec basename {} .fail \; | sed 's/^/  /'

# Generate a JSON test report
generate_json_report:
    @echo "Generating JSON report..."
    @success=$$(find $(RESULT_DIR) -type f -name '*.pass' | wc -l); \
    score=$$((success * 5)); \
    total_score=100; \
    channel="gitee"; \
    course_id=1546; \
    ext="aaa"; \
    name=""; \
    echo '{' &gt; $(RESULT_DIR)/report.json; \
    echo '  "channel": "'$$channel'"'',' &gt;&gt; $(RESULT_DIR)/report.json; \
    echo '  "courseId": ' $$course_id',' &gt;&gt; $(RESULT_DIR)/report.json; \
    echo '  "ext": "'$$ext'"'',' &gt;&gt; $(RESULT_DIR)/report.json; \
    echo '  "name": "'$$name'"'',' &gt;&gt; $(RESULT_DIR)/report.json; \
    echo '  "score": ' $$score',' &gt;&gt; $(RESULT_DIR)/report.json; \
    echo '  "totalScore": ' $$total_score &gt;&gt; $(RESULT_DIR)/report.json; \
    echo '}' &gt;&gt; $(RESULT_DIR)/report.json;

# Clean target: remove all generated files and directories
clean:
    for dir in $(EXERCISES); do \
        $(MAKE) -C $$dir clean; \
    done
    rm -rf $(BUILD_DIR) $(RESULT_DIR)

# Declare phony targets to prevent conflicts with file names
.PHONY: all clean $(EXERCISES) report generate_json_report
</code></pre>
<ul>
<li><strong>目录定义</strong>：
<ul>
<li><code>EXERCISE_DIR</code>：存放练习文件的目录。</li>
<li><code>TEST_DIR</code>：存放测试文件的目录。</li>
<li><code>BUILD_DIR</code>：存放构建产物的目录。</li>
</ul>
</li>
<li><strong>文件和目录操作</strong>：
<ul>
<li><code>mkdir -p $(TEST_DIR) $(BUILD_DIR)</code>：确保测试和构建目录存在。</li>
</ul>
</li>
<li><strong>编译和链接</strong>：
<ul>
<li><code>CC = gcc</code>：定义编译器为 gcc。</li>
<li><code>CFLAGS = -Wall -Wextra -std=c99</code>：编译选项，包括警告和 C99 标准。</li>
<li><code>LDFLAGS = -lm</code>：链接选项，链接数学库。</li>
</ul>
</li>
<li><strong>构建规则</strong>：
<ul>
<li><code>$(BUILD_DIR)/%: $(EXERCISE_DIR)/%.c</code>：为每个练习文件生成对应的执行文件。</li>
</ul>
</li>
<li><strong>清理规则</strong>：
<ul>
<li><code>clean</code>：删除所有执行文件和构建目录下的对象文件。</li>
</ul>
</li>
<li><strong>测试规则</strong>：
<ul>
<li><code>generate-test-cases</code>：生成测试用例。</li>
<li><code>test-output</code>：运行测试并比较输出结果。</li>
<li><code>save-test-results</code>：保存测试结果和通过率到 JSON 文件。</li>
</ul>
</li>
</ul>
<h2 id="使用-makefile-进行实验"><a class="header" href="#使用-makefile-进行实验">使用 makefile 进行实验</a></h2>
<p>在实验过程中，Makefile 提供了自动化构建和测试的便利。以下是如何使用这个 Makefile 进行实验的步骤：</p>
<ol>
<li>
<p><strong>编译所有练习</strong>：</p>
<pre><code class="language-bash">make
</code></pre>
<p>这个命令会编译所有练习文件，并在<code>BUILD_DIR</code>目录下生成对应的执行文件。</p>
</li>
<li>
<p><strong>生成测试用例</strong>：</p>
<pre><code class="language-bash">make generate-test-cases
</code></pre>
<p>这个命令会运行所有执行文件，并将输出保存为测试用例。</p>
</li>
<li>
<p><strong>运行测试</strong>：</p>
<pre><code class="language-bash">make test-output
</code></pre>
<p>这个命令会比较每个执行文件的输出与预期结果，并显示测试结果。</p>
</li>
<li>
<p><strong>保存测试结果</strong>：</p>
<pre><code class="language-bash">make save-test-results
</code></pre>
<p>这个命令会计算测试的通过率，并将结果保存到<code>test_results.json</code>文件中。</p>
</li>
<li>
<p><strong>清理</strong>：</p>
<pre><code class="language-bash">make clean
</code></pre>
<p>这个命令会删除所有构建产物和对象文件，保持环境整洁。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一题---makefile---编写第一份-makefile"><a class="header" href="#第一题---makefile---编写第一份-makefile">第一题 - MakeFile - 编写第一份 MakeFile</a></h1>
<h2 id="本节目录-16"><a class="header" href="#本节目录-16">本节目录</a></h2>
<ul>
<li><a href="ch6-02.html#%E7%AC%AC%E4%B8%80%E9%A2%98---makefile---%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%BB%BD-makefile">第一题 - MakeFile - 编写第一份 MakeFile</a>
<ul>
<li><a href="ch6-02.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-02.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch6-02.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch6-02.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch6-02.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a>
<ul>
<li><a href="ch6-02.html#%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6">源代码文件</a></li>
<li><a href="ch6-02.html#makefile-%E6%96%87%E4%BB%B6">MakeFile 文件</a></li>
</ul>
</li>
<li><a href="ch6-02.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch6-02.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求"><a class="header" href="#题目要求">题目要求</a></h2>
<p>编写你的第一个 Makefile 并运行，使结果能够通过测试。结果应该是，生成一个名为 <code>exercise-01</code> 的可执行文件。</p>
<h2 id="输入"><a class="header" href="#输入">输入</a></h2>
<pre><code class="language-bash"># 将会在测试脚本中尝试：
make all
</code></pre>
<h2 id="输出"><a class="header" href="#输出">输出</a></h2>
<p>应该产生一个名为 exercise-01 的可执行文件。</p>
<h2 id="已有代码介绍"><a class="header" href="#已有代码介绍">已有代码介绍</a></h2>
<p>已有三个源代码文件和一个 MakeFile 文件，你只需要修改 MakeFile 文件即可。</p>
<h3 id="源代码文件"><a class="header" href="#源代码文件">源代码文件</a></h3>
<ul>
<li><code>main.c</code>: 程序的入口点</li>
<li><code>functions.c</code>: 提供各种函数，其中包括 hello 函数</li>
<li><code>functions.h</code>: 提供函数声明</li>
</ul>
<h3 id="makefile-文件"><a class="header" href="#makefile-文件">MakeFile 文件</a></h3>
<pre><code class="language-makefile">CC ?= gcc

CFLAGS	?= -std=c11 -Wall -Wextra -Wpedantic -Werror -g
LDFLAGS ?= -Wl,--as-needed -Wl,--no-undefined

OUTPUT_DIR ?= .

SRCS	= main.c functions.c
OBJS	= $(SRCS:.c=.o)
TARGET	= $(OUTPUT_DIR)/exercise-01

all: $(TARGET)

$(OUTPUT_DIR):
	mkdir -p $(OUTPUT_DIR)

$(TARGET): $(OBJS)
	# 在这里指定 TARGET 的构建命令


%.o: %.c
	# 在这里指定 C 文件的编译命令

clean:
	rm -f $(TARGET) $(OBJS)
</code></pre>
<h2 id="提示"><a class="header" href="#提示">提示</a></h2>
<p>你需要在 MakeFile 文件中的中文注释附近，完成所需要执行的逻辑。如果遇到困难，那么大概率是因为三种情况引起：</p>
<ol>
<li>对 MakeFile 不熟，读不懂框架代码</li>
<li>只熟悉写死的 MakeFile，不知道使用 MakeFile 里的变量，读不懂框架代码</li>
<li>对 gcc 编译不熟，知道怎么写 MakeFile 但是不知道怎么写编译命令</li>
</ol>
<p>如果遇到上面问题，可以对症下药，通过视频、AI、问老师等多种方式进行解决。</p>
<h2 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h2>
<p><strong>不要修改源代码文件！</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二题---makefile---编写用于测试的-makefile"><a class="header" href="#第二题---makefile---编写用于测试的-makefile">第二题 - MakeFile - 编写用于测试的 MakeFile</a></h1>
<h2 id="本节目录-17"><a class="header" href="#本节目录-17">本节目录</a></h2>
<ul>
<li><a href="ch6-03.html#%E7%AC%AC%E4%BA%8C%E9%A2%98---makefile---%E7%BC%96%E5%86%99%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%9A%84-makefile">第二题 - MakeFile - 编写用于测试的 MakeFile</a>
<ul>
<li><a href="ch6-03.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-03.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch6-03.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch6-03.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch6-03.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a>
<ul>
<li><a href="ch6-03.html#%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6">源代码文件</a></li>
<li><a href="ch6-03.html#makefile-%E6%96%87%E4%BB%B6">MakeFile 文件</a></li>
</ul>
</li>
<li><a href="ch6-03.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch6-03.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-1"><a class="header" href="#题目要求-1">题目要求</a></h2>
<p>编写你的第一个 Makefile 并运行，使结果能够通过测试。结果应该是，既生成可执行文件 <code>exercise-02</code>，又生成可执行文件 <code>exercise-02_test</code>。</p>
<h2 id="输入-1"><a class="header" href="#输入-1">输入</a></h2>
<pre><code class="language-bash"># 将会在测试脚本中尝试：
make all
</code></pre>
<h2 id="输出-1"><a class="header" href="#输出-1">输出</a></h2>
<p>应该产生一个名为 <code>exercise-02</code> 的可执行文件和一个名为 <code>exercise-02_test</code> 的可执行文件。</p>
<h2 id="已有代码介绍-1"><a class="header" href="#已有代码介绍-1">已有代码介绍</a></h2>
<p>已有四个源代码文件和一个 MakeFile 文件，你只需要修改 MakeFile 文件即可。</p>
<h3 id="源代码文件-1"><a class="header" href="#源代码文件-1">源代码文件</a></h3>
<ul>
<li><code>main.c</code>: 程序的入口点</li>
<li><code>functions.c</code>: 提供各种函数，其中包括 hello 函数</li>
<li><code>functions.h</code>: 提供函数声明</li>
<li><code>test.c</code>： 用于提供测试的源代码文件</li>
</ul>
<h3 id="makefile-文件-1"><a class="header" href="#makefile-文件-1">MakeFile 文件</a></h3>
<pre><code class="language-makefile">CC ?= gcc

CFLAGS	?= -std=c11 -Wall -Wextra -Wpedantic -Werror -g
LDFLAGS ?= -Wl,--as-needed -Wl,--no-undefined

OUTPUT_DIR ?= .

SRCS		= main.c functions.c
OBJS		= $(SRCS:.c=.o)
TARGET		= $(OUTPUT_DIR)/exercise-02

TEST_SRCS	= test.c functions.c
TEST_OBJS	= $(TEST_SRCS:.c=.o)
TEST_TARGET = $(OUTPUT_DIR)/exercise-02_test

all: $(TARGET) test

$(OUTPUT_DIR):
	mkdir -p $(OUTPUT_DIR)

$(TARGET): $(OBJS)
	# 在这里指定 TARGET 的构建命令

$(TEST_TARGET): $(TEST_OBJS)
	# 在这里指定 TEST_TARGET 的构建命令

%.o: %.c
	# 在这里指定所有 C 文件的编译命令

test: $(TEST_TARGET)
	$(TEST_TARGET)

clean:
	rm -f $(TARGET) $(TEST_TARGET) $(OBJS) $(TEST_OBJS)

</code></pre>
<h2 id="提示-1"><a class="header" href="#提示-1">提示</a></h2>
<p>你需要在 MakeFile 文件中的中文注释附近，完成所需要执行的逻辑。有和上一题相似的地方的话，可以考虑复用。剩下的内容，如果遇到困难，那么大概率是因为三种情况引起：</p>
<ol>
<li>对 MakeFile 不熟，读不懂框架代码</li>
<li>只熟悉写死的 MakeFile，不知道使用 MakeFile 里的变量，读不懂框架代码</li>
<li>对 gcc 编译不熟，知道怎么写 MakeFile 但是不知道怎么写编译命令</li>
</ol>
<p>如果遇到上面问题，可以对症下药，通过视频、AI、问老师等多种方式进行解决。</p>
<h2 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h2>
<p><strong>不要修改源代码文件！</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第三题---makefile---静态链接程序"><a class="header" href="#第三题---makefile---静态链接程序">第三题 - MakeFile - 静态链接程序</a></h1>
<h2 id="本节目录-18"><a class="header" href="#本节目录-18">本节目录</a></h2>
<ul>
<li><a href="ch6-04.html#%E7%AC%AC%E4%B8%89%E9%A2%98---makefile---%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%A8%8B%E5%BA%8F">第三题 - MakeFile - 静态链接程序</a>
<ul>
<li><a href="ch6-04.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-04.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch6-04.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch6-04.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch6-04.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a>
<ul>
<li><a href="ch6-04.html#%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6">源代码文件</a></li>
<li><a href="ch6-04.html#makefile-%E6%96%87%E4%BB%B6">MakeFile 文件</a></li>
</ul>
</li>
<li><a href="ch6-04.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch6-04.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-2"><a class="header" href="#题目要求-2">题目要求</a></h2>
<ul>
<li>编译和链接两个源文件 <code>functions.c</code> 和 <code>main.c</code> 以生成一个可执行程序。</li>
<li>修改 Makefile，能够将 <code>functions.c</code> 编译为中间产物 <code>functions.a</code>，最终使用该产物静态链接出可执行程序并运行它。</li>
<li>此处的“它”指能够成功生成 Makefile 中的 TARGET 和 TEST_TARGET。</li>
</ul>
<h2 id="输入-2"><a class="header" href="#输入-2">输入</a></h2>
<pre><code class="language-bash"># 将会在测试脚本中尝试：
make all
</code></pre>
<h2 id="输出-2"><a class="header" href="#输出-2">输出</a></h2>
<p>应该产生一个名为 <code>exercise-03</code> 的可执行文件和一个名为 <code>exercise-03_test</code> 的可执行文件。</p>
<h2 id="已有代码介绍-2"><a class="header" href="#已有代码介绍-2">已有代码介绍</a></h2>
<p>已有五个源代码文件和一个 MakeFile 文件，你只需要修改 MakeFile 文件即可。</p>
<h3 id="源代码文件-2"><a class="header" href="#源代码文件-2">源代码文件</a></h3>
<ul>
<li><code>main.c</code>: 程序的入口点</li>
<li><code>functions.c</code>: 提供各种函数，其中包括 hello 函数</li>
<li><code>functions.h</code>: 提供函数声明</li>
<li><code>test.c</code>：用于提供对 hello 函数进行测试的源代码文件</li>
<li><code>tests.c</code>：用于测试静态链接情况的源代码文件</li>
</ul>
<h3 id="makefile-文件-2"><a class="header" href="#makefile-文件-2">MakeFile 文件</a></h3>
<pre><code class="language-makefile">CC ?= gcc

CFLAGS	= -std=c11 -Wall -Wextra -Wpedantic -Werror -g
# 注意需要指定 -static
LDFLAGS = -static

OUTPUT_DIR ?= .

SRCS		= main.c functions.c
OBJS		= $(SRCS:.c=.o)
TARGET		= $(OUTPUT_DIR)/exercise-03

TEST_SRCS	= test.c functions.c
TEST_OBJS	= $(TEST_SRCS:.c=.o)
TEST_TARGET = $(OUTPUT_DIR)/exercise-03_test

all: $(TARGET)

$(TARGET): $(OBJS)
	# 在这里指定 TARGET 的构建命令

$(TEST_TARGET): $(TEST_OBJS)
	# 在这里指定 TEST_TARGET 的构建命令

%.o: %.c
	# 在这里指定所有 C 文件的编译命令

test: $(TEST_TARGET)
	./$(TEST_TARGET)

clean:
	rm -f $(TARGET) $(TEST_TARGET) $(OBJS) $(TEST_OBJS)

</code></pre>
<h2 id="提示-2"><a class="header" href="#提示-2">提示</a></h2>
<p>你需要在 MakeFile 文件中的中文注释附近，完成所需要执行的逻辑。有和上一题相似的地方的话，可以考虑复用。剩下的内容，如果遇到困难，那么大概率是因为三种情况引起：</p>
<ol>
<li>对 MakeFile 不熟，读不懂框架代码</li>
<li>只熟悉写死的 MakeFile，不知道使用 MakeFile 里的变量，读不懂框架代码</li>
<li>对 gcc 编译不熟，知道怎么写 MakeFile 但是不知道怎么写编译命令</li>
</ol>
<p>如果遇到上面问题，可以对症下药，通过视频、AI、问老师等多种方式进行解决。比如，可以搜索“gcc 静态链接”。</p>
<h2 id="注意事项-2"><a class="header" href="#注意事项-2">注意事项</a></h2>
<p><strong>不要修改源代码文件！</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第四题---makefile---构建第一个静态链接库"><a class="header" href="#第四题---makefile---构建第一个静态链接库">第四题 - MakeFile - 构建第一个静态链接库</a></h1>
<h2 id="本节目录-19"><a class="header" href="#本节目录-19">本节目录</a></h2>
<ul>
<li><a href="ch6-05.html#%E7%AC%AC%E5%9B%9B%E9%A2%98---makefile---%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93">第四题 - MakeFile - 构建第一个静态链接库</a>
<ul>
<li><a href="ch6-05.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-05.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch6-05.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch6-05.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch6-05.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a>
<ul>
<li><a href="ch6-05.html#%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6">源代码文件</a></li>
<li><a href="ch6-05.html#makefile-%E6%96%87%E4%BB%B6">MakeFile 文件</a></li>
</ul>
</li>
<li><a href="ch6-05.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch6-05.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-3"><a class="header" href="#题目要求-3">题目要求</a></h2>
<ul>
<li>修改 Makefile，能够将 <code>functions.c</code> 编译为静态库 <code>libfunctions.a</code></li>
<li>使用该库编译出可执行程序并运行它。</li>
<li>此处的“它”指能够成功生成 Makefile 中的 TARGET 和 TEST_TARGET。</li>
</ul>
<h2 id="输入-3"><a class="header" href="#输入-3">输入</a></h2>
<pre><code class="language-bash"># 将会在测试脚本中尝试：
make all
</code></pre>
<h2 id="输出-3"><a class="header" href="#输出-3">输出</a></h2>
<p>应该产生一个名为 <code>exercise-04</code> 的可执行文件和一个名为 <code>exercise-04_test</code> 的可执行文件。</p>
<h2 id="已有代码介绍-3"><a class="header" href="#已有代码介绍-3">已有代码介绍</a></h2>
<p>已有四个源代码文件和一个 MakeFile 文件，你只需要修改 MakeFile 文件即可。</p>
<h3 id="源代码文件-3"><a class="header" href="#源代码文件-3">源代码文件</a></h3>
<ul>
<li><code>main.c</code>: 程序的入口点</li>
<li><code>functions.c</code>: 提供各种函数，其中包括 hello 函数</li>
<li><code>functions.h</code>: 提供函数声明</li>
<li><code>test.c</code>：用于提供对 hello 函数进行测试的源代码文件</li>
</ul>
<h3 id="makefile-文件-3"><a class="header" href="#makefile-文件-3">MakeFile 文件</a></h3>
<pre><code class="language-makefile">CC ?= gcc

CFLAGS	= -std=c11 -Wall -Wextra -Wpedantic -Werror -g
LDFLAGS = -Wl,--as-needed -Wl,--no-undefined

OUTPUT_DIR ?= .

SRCS		= main.c
OBJS		= $(SRCS:.c=.o)
TARGET		= $(OUTPUT_DIR)/exercise-04

LIB_NAME	= libfunctions.a
LIB_TARGET	= $(OUTPUT_DIR)/$(LIB_NAME)
LIB_SRC		= functions.c
LIB_OBJ		= $(LIB_SRC:.c=.o)

TEST_SRCS	= test.c functions.c
TEST_OBJS	= $(TEST_SRCS:.c=.o)
TEST_TARGET = $(OUTPUT_DIR)/exercise-04_test

all: $(TARGET) test

$(OUTPUT_DIR):
	mkdir -p $(OUTPUT_DIR)

$(LIB_OBJ): $(LIB_SRC)
	# 在这里指定如何编译 functions.o

$(LIB_TARGET): $(LIB_OBJ)
	# 在这里指定如何生成静态链接库

$(TARGET): $(OBJS) $(LIB_TARGET)
	# 在这里指定如何链接 libfunctions.a 来生成 TARGET

$(TEST_TARGET): $(TEST_OBJS) $(LIB_TARGET)
	# 在这里指定如何链接 libfunctions.a 来生成 TEST_TARGET

%.o: %.c
	# 在这里指定所有 C 文件的编译命令

test: $(TEST_TARGET)
	$(TEST_TARGET)

clean:
	rm -f $(LIB_TARGET) $(TARGET) $(TEST_TARGET) $(OBJS) $(LIB_OBJ) $(TEST_OBJS)

</code></pre>
<h2 id="提示-3"><a class="header" href="#提示-3">提示</a></h2>
<p>你需要在 MakeFile 文件中的中文注释附近，完成所需要执行的逻辑。有和上一题相似的地方的话，可以考虑复用。剩下的内容，如果遇到困难，那么大概率是因为三种情况引起：</p>
<ol>
<li>对 MakeFile 不熟，读不懂框架代码</li>
<li>只熟悉写死的 MakeFile，不知道使用 MakeFile 里的变量，读不懂框架代码</li>
<li>对 gcc 编译不熟，知道怎么写 MakeFile 但是不知道怎么写编译命令</li>
</ol>
<p>如果遇到上面问题，可以对症下药，通过视频、AI、问老师等多种方式进行解决。比如，可以搜索“gcc 生成静态库”。</p>
<h2 id="注意事项-3"><a class="header" href="#注意事项-3">注意事项</a></h2>
<p><strong>不要修改源代码文件！</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第五题---makefile---构建第一个动态链接库"><a class="header" href="#第五题---makefile---构建第一个动态链接库">第五题 - MakeFile - 构建第一个动态链接库</a></h1>
<h2 id="本节目录-20"><a class="header" href="#本节目录-20">本节目录</a></h2>
<ul>
<li><a href="ch6-06.html#%E7%AC%AC%E4%BA%94%E9%A2%98---makefile---%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93">第五题 - MakeFile - 构建第一个动态链接库</a>
<ul>
<li><a href="ch6-06.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-06.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch6-06.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch6-06.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch6-06.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a>
<ul>
<li><a href="ch6-06.html#%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6">源代码文件</a></li>
<li><a href="ch6-06.html#makefile-%E6%96%87%E4%BB%B6">MakeFile 文件</a></li>
</ul>
</li>
<li><a href="ch6-06.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch6-06.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-4"><a class="header" href="#题目要求-4">题目要求</a></h2>
<ul>
<li>修改 Makefile，能够将 <code>functions.c</code> 编译为动态链接库 <code>libfunctions.so</code></li>
<li>使用该库编译出可执行程序并运行它。</li>
<li>此处的“它”指能够成功生成 Makefile 中的 TARGET 和 TEST_TARGET。</li>
</ul>
<h2 id="输入-4"><a class="header" href="#输入-4">输入</a></h2>
<pre><code class="language-bash"># 将会在测试脚本中尝试：
make all
</code></pre>
<h2 id="输出-4"><a class="header" href="#输出-4">输出</a></h2>
<p>应该产生一个名为 <code>exercise-05</code> 的可执行文件和一个名为 <code>exercise-05_test</code> 的可执行文件。</p>
<h2 id="已有代码介绍-4"><a class="header" href="#已有代码介绍-4">已有代码介绍</a></h2>
<p>已有四个源代码文件和一个 MakeFile 文件，你只需要修改 MakeFile 文件即可。</p>
<h3 id="源代码文件-4"><a class="header" href="#源代码文件-4">源代码文件</a></h3>
<ul>
<li><code>main.c</code>: 程序的入口点</li>
<li><code>functions.c</code>: 提供各种函数，其中包括 hello 函数</li>
<li><code>functions.h</code>: 提供函数声明</li>
<li><code>test.c</code>：用于提供对 hello 函数进行测试的源代码文件</li>
</ul>
<h3 id="makefile-文件-4"><a class="header" href="#makefile-文件-4">MakeFile 文件</a></h3>
<pre><code class="language-makefile">CC ?= gcc

CFLAGS	= -std=c11 -Wall -Wextra -Wpedantic -Werror -g
LDFLAGS = -Wl,--as-needed -Wl,--no-undefined

OUTPUT_DIR ?= .

SRCS		= main.c
OBJS		= $(SRCS:.c=.o)
TARGET		= $(OUTPUT_DIR)/exercise-05

LIB_NAME	= libfunctions.so
LIB_TARGET	= $(OUTPUT_DIR)/$(LIB_NAME)
LIB_SRC		= functions.c
LIB_OBJ		= $(LIB_SRC:.c=.o)
RPATH		=  -Wl,-rpath,'$$ORIGIN'

TEST_SRCS	= test.c functions.c
TEST_OBJS	= $(TEST_SRCS:.c=.o)
TEST_TARGET = $(OUTPUT_DIR)/exercise-05_test

all: $(TARGET) test

$(OUTPUT_DIR):
	mkdir -p $(OUTPUT_DIR)

$(LIB_OBJ): $(LIB_SRC)
	# 在这里指定如何编译 libfunctions.o

$(LIB_TARGET): $(LIB_OBJ)
	# 在这里指定如何生成 libfunctions.so

$(TARGET): $(OBJS) $(LIB_TARGET)
	# 在这里指定如何链接 libfunctions.so 来生成 TARGET

$(TEST_TARGET): $(TEST_OBJS) $(LIB_TARGET)
	# 在这里指定如何链接 libfunctions.so 来生成 TEST_TARGET

%.o: %.c
	# 在这里指定如何编译所有 C 文件

test: $(TEST_TARGET)
	$(TEST_TARGET)

clean:
	rm -f $(LIB_TARGET) $(TARGET) $(TEST_TARGET) $(OBJS) $(LIB_OBJ) $(TEST_OBJS)

</code></pre>
<h2 id="提示-4"><a class="header" href="#提示-4">提示</a></h2>
<p>你需要在 MakeFile 文件中的中文注释附近，完成所需要执行的逻辑。有和上一题相似的地方的话，可以考虑复用。剩下的内容，如果遇到困难，那么大概率是因为三种情况引起：</p>
<ol>
<li>对 MakeFile 不熟，读不懂框架代码</li>
<li>只熟悉写死的 MakeFile，不知道使用 MakeFile 里的变量，读不懂框架代码</li>
<li>对 gcc 编译不熟，知道怎么写 MakeFile 但是不知道怎么写编译命令</li>
</ol>
<p>如果遇到上面问题，可以对症下药，通过视频、AI、问老师等多种方式进行解决。比如，可以搜索“gcc 生成动态库”。</p>
<h2 id="注意事项-4"><a class="header" href="#注意事项-4">注意事项</a></h2>
<p><strong>不要修改源代码文件！</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第六题---ld-脚本---指定内存区域"><a class="header" href="#第六题---ld-脚本---指定内存区域">第六题 - ld 脚本 - 指定内存区域</a></h1>
<h2 id="本节目录-21"><a class="header" href="#本节目录-21">本节目录</a></h2>
<ul>
<li><a href="ch6-07.html#%E7%AC%AC%E5%85%AD%E9%A2%98---ld-%E8%84%9A%E6%9C%AC---%E6%8C%87%E5%AE%9A%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">第六题 - ld 脚本 - 指定内存区域</a>
<ul>
<li><a href="ch6-07.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-07.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch6-07.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch6-07.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch6-07.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch6-07.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch6-07.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-5"><a class="header" href="#题目要求-5">题目要求</a></h2>
<p>编写一个 ld 文件（命名为 <code>memory_region.ld</code>），设置内存区域起始地址为 0x8000000，长度为 0x2000。</p>
<h2 id="输入-5"><a class="header" href="#输入-5">输入</a></h2>
<pre><code class="language-shell"># 将会在测试脚本中尝试：
# 打印程序入口地址，匹配是否为 0x8000000
$(readelf -l "$EXECUTABLE" | grep "Entry point" | head -n 1 | awk '{print $3}')
</code></pre>
<h2 id="输出-5"><a class="header" href="#输出-5">输出</a></h2>
<p>运行测试时，检测到"Test passed."字样。</p>
<h2 id="已有代码介绍-5"><a class="header" href="#已有代码介绍-5">已有代码介绍</a></h2>
<pre><code class="language-c">MEMORY {
    /* &gt;&gt;&gt; 在这里定义内存区域，设置内存区域起始地址为 `0x8000000`，长度为 `0x2000`。 */

    /* &lt;&lt;&lt; */
}


SECTIONS {
    /* 定义代码段，包含可执行程序的指令 */
    .text : {
        *(.text)
       /* 其他段的定义 */
    }

    /* 定义只读数据段，包含常量数据 */
    .rodata : {
        *(.rodata)
    } &gt; RAM

    /* 定义BSS段，包含未初始化的全局变量和静态变量 */
    .bss : {
        *(.bss)
    } &gt; RAM

    /* 定义程序头表 */
    . = ALIGN(4);
    .interp : { *(.interp) }
    .note.gnu.build-id : { *(.note.gnu.build-id) }
    .dynamic : { *(.dynamic) }
    .hash : { *(.hash) }
    .gnu.hash : { *(.gnu.hash) }
    .dynsym : { *(.dynsym) }
    .dynstr : { *(.dynstr) }
    .gnu.version : { *(.gnu.version) }
    .gnu.version_d : { *(.gnu.version_d) }
    .gnu.version_r : { *(.gnu.version_r) }
    .eh_frame : { *(.eh_frame) }
    . = ALIGN(8);
    . = . + SIZEOF_HEADERS;
}

</code></pre>
<h2 id="提示-5"><a class="header" href="#提示-5">提示</a></h2>
<p>你需要了解 ld 脚本的结构，之后，在 Memory 内，按照中文注释完成对应要求。</p>
<h2 id="注意事项-5"><a class="header" href="#注意事项-5">注意事项</a></h2>
<p><strong>无特殊注意事项</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第七题---ld-脚本---指定-text-起始地址"><a class="header" href="#第七题---ld-脚本---指定-text-起始地址">第七题 - ld 脚本 - 指定 text 起始地址</a></h1>
<h2 id="本节目录-22"><a class="header" href="#本节目录-22">本节目录</a></h2>
<ul>
<li><a href="ch6-08.html#%E7%AC%AC%E4%B8%83%E9%A2%98---ld-%E8%84%9A%E6%9C%AC---%E6%8C%87%E5%AE%9A-text-%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80">第七题 - ld 脚本 - 指定 text 起始地址</a>
<ul>
<li><a href="ch6-08.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-08.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch6-08.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch6-08.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch6-08.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch6-08.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch6-08.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-6"><a class="header" href="#题目要求-6">题目要求</a></h2>
<p>编写一个 ld 文件（命名为 <code>text_adress_.ld</code>），设置内存区域起始地址为 0x8000000，长度为 0x2000，指定 .text 的起始地址为 0x1000。</p>
<h2 id="输入-6"><a class="header" href="#输入-6">输入</a></h2>
<pre><code class="language-shell"># 将会在测试脚本中尝试：
# 打印 `text` 地址，匹配是否为 0x1000
$(readelf -l "$EXECUTABLE" | grep "Entry point" | head -n 1 | awk '{print $3}')
</code></pre>
<h2 id="输出-6"><a class="header" href="#输出-6">输出</a></h2>
<p>运行测试时，检测到"Test passed."字样。</p>
<h2 id="已有代码介绍-6"><a class="header" href="#已有代码介绍-6">已有代码介绍</a></h2>
<pre><code class="language-c">MEMORY {
    /* &gt;&gt;&gt; 在这里定义内存区域，设置内存区域起始地址为 `0x8000000`，长度为 `0x2000`。 */

    /* &lt;&lt;&lt; */
}


SECTIONS {
    /* &gt;&gt;&gt; 在这里指定 `.text` 的起始地址为 `0x1000` */
    .text : {
        *(.text)
        /* 其他段的定义 */
    }
    /* &lt;&lt;&lt; */

    /* 定义只读数据段，包含常量数据 */
    .rodata : {
        *(.rodata)
    } &gt; RAM

    /* 定义BSS段，包含未初始化的全局变量和静态变量 */
    .bss : {
        *(.bss)
    } &gt; RAM

    /* 定义程序头表 */
    . = ALIGN(4);
    .interp : { *(.interp) }
    .note.gnu.build-id : { *(.note.gnu.build-id) }
    .dynamic : { *(.dynamic) }
    .hash : { *(.hash) }
    .gnu.hash : { *(.gnu.hash) }
    .dynsym : { *(.dynsym) }
    .dynstr : { *(.dynstr) }
    .gnu.version : { *(.gnu.version) }
    .gnu.version_d : { *(.gnu.version_d) }
    .gnu.version_r : { *(.gnu.version_r) }
    .eh_frame : { *(.eh_frame) }
    . = ALIGN(8);
    . = . + SIZEOF_HEADERS;
}

</code></pre>
<h2 id="提示-6"><a class="header" href="#提示-6">提示</a></h2>
<p>你需要了解 ld 脚本的结构，之后，在 Memory 和 SECTIONS 内，按照中文注释完成对应要求。有和上一题相似的地方的话，可以考虑复用。</p>
<h2 id="注意事项-6"><a class="header" href="#注意事项-6">注意事项</a></h2>
<p><strong>虽然测试脚本内没有对 Memory 内容进行测试，但仍然要进行实现！</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第八题---ld-脚本---指定自定义-symbol"><a class="header" href="#第八题---ld-脚本---指定自定义-symbol">第八题 - ld 脚本 - 指定自定义 symbol</a></h1>
<h2 id="本节目录-23"><a class="header" href="#本节目录-23">本节目录</a></h2>
<ul>
<li><a href="ch6-09.html#%E7%AC%AC%E5%85%AB%E9%A2%98---ld-%E8%84%9A%E6%9C%AC---%E6%8C%87%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89-symbol">第八题 - ld 脚本 - 指定自定义 symbol</a>
<ul>
<li><a href="ch6-09.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-09.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch6-09.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch6-09.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch6-09.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch6-09.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch6-09.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-7"><a class="header" href="#题目要求-7">题目要求</a></h2>
<p>编写一个 ld 文件（命名为 new_symbol.ld），设置内存区域起始地址为 0x8000000，长度为 0x2000，指定 .text 包含一个自定义的 symbol 名为 my_custom_symbol，其地址为 0x1111。</p>
<h2 id="输入-7"><a class="header" href="#输入-7">输入</a></h2>
<pre><code class="language-shell"># 将会在测试脚本中尝试：
# 打印 `my_custom_symbol` 的地址，匹配是否为 0000000008001111
# 起始地址 + symbol 偏移地址 应该是 0000000008001111
$(nm "$EXECUTABLE" | grep ' my_custom_symbol$' | awk '{print $1}')
</code></pre>
<h2 id="输出-7"><a class="header" href="#输出-7">输出</a></h2>
<p>运行测试时，检测到"Test passed."字样。</p>
<h2 id="已有代码介绍-7"><a class="header" href="#已有代码介绍-7">已有代码介绍</a></h2>
<pre><code class="language-c">MEMORY {
    /* &gt;&gt;&gt; 在这里定义内存区域，设置内存区域起始地址为 `0x8000000`，长度为 `0x2000`。 */

    /* &lt;&lt;&lt; */
}


SECTIONS {
    .text : {
        *(.text)
        /* 其他段的定义 */

        /* &gt;&gt;&gt; 在这里添加 my_custom_symbol，地址设置 0x1111 。*/

        /* &lt;&lt;&lt; */
    }
    /* &lt;&lt;&lt; */


    /* 定义只读数据段，包含常量数据 */
    .rodata : {
        *(.rodata)
    } &gt; RAM

    /* 定义BSS段，包含未初始化的全局变量和静态变量 */
    .bss : {
        *(.bss)
    } &gt; RAM

    /* 定义程序头表 */
    . = ALIGN(4);
    .interp : { *(.interp) }
    .note.gnu.build-id : { *(.note.gnu.build-id) }
    .dynamic : { *(.dynamic) }
    .hash : { *(.hash) }
    .gnu.hash : { *(.gnu.hash) }
    .dynsym : { *(.dynsym) }
    .dynstr : { *(.dynstr) }
    .gnu.version : { *(.gnu.version) }
    .gnu.version_d : { *(.gnu.version_d) }
    .gnu.version_r : { *(.gnu.version_r) }
    .eh_frame : { *(.eh_frame) }
    . = ALIGN(8);
    . = . + SIZEOF_HEADERS;
}

</code></pre>
<h2 id="提示-7"><a class="header" href="#提示-7">提示</a></h2>
<p>你需要了解 ld 脚本的结构，之后，在 Memory 和 SECTIONS 内，按照中文注释完成对应要求。有和上一题相似的地方的话，可以考虑复用。</p>
<h2 id="注意事项-7"><a class="header" href="#注意事项-7">注意事项</a></h2>
<p><strong>无特殊注意事项</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第九题---ld-脚本---指定自定义-section"><a class="header" href="#第九题---ld-脚本---指定自定义-section">第九题 - ld 脚本 - 指定自定义 section</a></h1>
<h2 id="本节目录-24"><a class="header" href="#本节目录-24">本节目录</a></h2>
<ul>
<li><a href="ch6-10.html#%E7%AC%AC%E4%B9%9D%E9%A2%98---ld-%E8%84%9A%E6%9C%AC---%E6%8C%87%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89-section">第九题 - ld 脚本 - 指定自定义 section</a>
<ul>
<li><a href="ch6-10.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch6-10.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch6-10.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch6-10.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch6-10.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch6-10.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch6-10.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-8"><a class="header" href="#题目要求-8">题目要求</a></h2>
<p>编写一个 ld 文件（命名为 <code>custom_section_.ld</code>），设置内存区域起始地址为 0x8000000，长度为 0x2000，指定 setions 包含一个自定义的 section 名为 <code>my_custom_section</code>，并在 <code>my_custom_section</code> 内放置 <code>my_custom_data</code>，其地址为 0x1234。</p>
<h2 id="输入-8"><a class="header" href="#输入-8">输入</a></h2>
<pre><code class="language-shell"># 将会在测试脚本中尝试：
# 打印 `my_custom_data` 的地址，匹配是否为 0000000000001234
$(readelf -s "$EXECUTABLE" | grep ' my_custom_data$' | awk '{print $2}')
</code></pre>
<h2 id="输出-8"><a class="header" href="#输出-8">输出</a></h2>
<p>运行测试时，检测到"Test passed."字样。</p>
<h2 id="已有代码介绍-8"><a class="header" href="#已有代码介绍-8">已有代码介绍</a></h2>
<pre><code class="language-c">MEMORY {
    /* &gt;&gt;&gt; 在这里定义内存区域，设置内存区域起始地址为 `0x8000000`，长度为 `0x2000`。 */

    /* &lt;&lt;&lt; */
}


SECTIONS {
    .text : {
        *(.text)
        /* 其他段的定义 */
    }


    /* 定义只读数据段，包含常量数据 */
    .rodata : {
        *(.rodata)
    } &gt; RAM

    /* 定义BSS段，包含未初始化的全局变量和静态变量 */
    .bss : {
        *(.bss)
    } &gt; RAM

    /* &gt;&gt;&gt; 在这里添加 my_custom_sectoin，并在其内放置 `my_custom_data`，地址设置 0x1234 。*/

    /* &lt;&lt;&lt; */


    /* 定义程序头表 */
    . = ALIGN(4);
    .interp : { *(.interp) }
    .note.gnu.build-id : { *(.note.gnu.build-id) }
    .dynamic : { *(.dynamic) }
    .hash : { *(.hash) }
    .gnu.hash : { *(.gnu.hash) }
    .dynsym : { *(.dynsym) }
    .dynstr : { *(.dynstr) }
    .gnu.version : { *(.gnu.version) }
    .gnu.version_d : { *(.gnu.version_d) }
    .gnu.version_r : { *(.gnu.version_r) }
    .eh_frame : { *(.eh_frame) }
    . = ALIGN(8);
    . = . + SIZEOF_HEADERS;
}

</code></pre>
<h2 id="提示-8"><a class="header" href="#提示-8">提示</a></h2>
<p>你需要了解 ld 脚本的结构，之后，在 Memory 和 SECTIONS 内，按照中文注释完成对应要求。有和上一题相似的地方的话，可以考虑复用。</p>
<h2 id="注意事项-8"><a class="header" href="#注意事项-8">注意事项</a></h2>
<p><strong>无特殊注意事项</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第七章---题目分析10---20"><a class="header" href="#第七章---题目分析10---20">第七章 - 题目分析[10 - 20]</a></h1>
<h2 id="本章概要-4"><a class="header" href="#本章概要-4">本章概要</a></h2>
<p>本章主要进行的习题知识点范围如下：</p>
<ul>
<li>操作系统里常用的数据结构 - 队列</li>
<li>内核模块</li>
<li>Risc-V 汇编</li>
</ul>
<p>对于数据结构，我们会做两道题，分别为：</p>
<ol>
<li>合并两个队列</li>
<li>按组反转一个队列</li>
</ol>
<p>在数据结构部分，需要大家能够按照指定思想，复现出对应的算法。</p>
<p>对于内核模块，我们会做六道题，分别为：</p>
<ol>
<li>编写一个内核模块打印 hello world</li>
<li>编写一个内核模块实现阶乘计算</li>
<li>编写一个内核模块实现字符串反转</li>
<li>编写一个内核模块实现平均数计算</li>
<li>编写一个内核模块实现线性查找</li>
<li>编写一个内核模块延时打印字符串</li>
</ol>
<p>在内核模块，主要需要大家掌握内核模块的编程方法，并实现一些基础算法。</p>
<p>对于 Risc-V 汇编，我们会做三道题，分别为：</p>
<ol>
<li>使用 RISC-V 内联汇编实现条件返回</li>
<li>使用 RISC-V 内联汇编实现最大公因数求解</li>
<li>使用 RISC-V 内联汇编实现数组元素查找</li>
</ol>
<p>在 Risc-V 汇编部分，主要需要大家掌握 RISC-V 内联汇编的基本用法，推荐大家参考 Risc-V 汇编手册。</p>
<h2 id="本章目录-7"><a class="header" href="#本章目录-7">本章目录</a></h2>
<ul>
<li><a href="./ch7-01.html">第十题 - 数据结构(队列) - 合并两个队列</a></li>
<li><a href="./ch7-02.html">第十一题 - 数据结构(队列) - 按组反转一个队列</a></li>
<li><a href="./ch7-03.html">第十二题 - 内核模块 - 打印 hello world</a></li>
<li><a href="./ch7-04.html">第十三题 - 内核模块 - 阶乘计算</a></li>
<li><a href="./ch7-05.html">第十四题 - 内核模块 - 字符串反转</a></li>
<li><a href="./ch7-06.html">第十五题 - 内核模块 - 平均数计算</a></li>
<li><a href="./ch7-07.html">第十六题 - 内核模块 - 线性查找</a></li>
<li><a href="./ch7-08.html">第十七题 - 内核模块 - 延时打印字符串</a></li>
<li><a href="./ch7-09.html">第十八题 - Risc-V 汇编 - 条件返回</a></li>
<li><a href="./ch7-10.html">第十九题 - Risc-V 汇编 - 最大公因数求解</a></li>
<li><a href="./ch7-11.html">第二十题 - Risc-V 汇编 - 数组元素查找</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十题---数据结构队列---合并两个队列"><a class="header" href="#第十题---数据结构队列---合并两个队列">第十题 - 数据结构(队列) - 合并两个队列</a></h1>
<h2 id="本节目录-25"><a class="header" href="#本节目录-25">本节目录</a></h2>
<ul>
<li><a href="ch7-01.html#%E7%AC%AC%E5%8D%81%E9%A2%98---%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%9F%E5%88%97---%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97">第十题 - 数据结构(队列) - 合并两个队列</a>
<ul>
<li><a href="ch7-01.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-01.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-01.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-01.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-01.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-01.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-01.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-01.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-9"><a class="header" href="#题目要求-9">题目要求</a></h2>
<p>将两个任务队列（例如运行队列）合并在一起，这在多核处理器中尤为常见，当某个处理器的任务队列需要与另一个处理器的任务队列合并时，可以使用这一操作。</p>
<p>你需要实现一个函数 <code>merge_task_queues</code>，该函数用于合并两个已经排序的任务队列。每个任务队列由 TaskNode 结构体表示，任务队列按任务 ID (task_id) 从小到大排序。合并后的任务队列也需要保持有序。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<p>假设我们有两个任务队列：</p>
<p>队列 A：1 -&gt; 3 -&gt; 5
队列 B：2 -&gt; 4 -&gt; 6
调用 <code>merge_task_queues(A, B)</code> 后，返回的新队列应该是：</p>
<p>合并后的队列：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</p>
<h2 id="输入-9"><a class="header" href="#输入-9">输入</a></h2>
<p>一组任务 id 组成的的队列，由 <code>,</code> 分割，比如 1,3,5。
另一组任务 id 组成的的队列，由 <code>,</code> 分割，比如 2,4,6。</p>
<h2 id="输出-9"><a class="header" href="#输出-9">输出</a></h2>
<p>打印合并后的任务队列：</p>
<p>Merged Queue: 1 2 3 4 5 6</p>
<h2 id="已有代码介绍-9"><a class="header" href="#已有代码介绍-9">已有代码介绍</a></h2>
<p>任务队列的节点由以下结构体表示：</p>
<pre><code class="language-c">typedef struct TaskNode {
    int task_id;
    struct TaskNode *next;
} TaskNode;
</code></pre>
<h2 id="提示-9"><a class="header" href="#提示-9">提示</a></h2>
<ul>
<li>初始的任务队列已经安装升序排序完毕，合并后的队列也要以升序排列。</li>
<li>在原地操作即可，不需要申请新的内存空间。</li>
<li>同时遍历两个队列，不断选出最小的任务 id，然后将其插入到新队列的末尾。</li>
</ul>
<h2 id="注意事项-9"><a class="header" href="#注意事项-9">注意事项</a></h2>
<p>记得判断退出了 while 循环后，是否仍然有非空队列，如果有，则应该进一步合并。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十一题---数据结构队列---按组反转一个队列"><a class="header" href="#第十一题---数据结构队列---按组反转一个队列">第十一题 - 数据结构(队列) - 按组反转一个队列</a></h1>
<h2 id="本节目录-26"><a class="header" href="#本节目录-26">本节目录</a></h2>
<ul>
<li><a href="ch7-02.html#%E7%AC%AC%E5%8D%81%E4%B8%80%E9%A2%98---%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%9F%E5%88%97---%E6%8C%89%E7%BB%84%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97">第十一题 - 数据结构(队列) - 按组反转一个队列</a>
<ul>
<li><a href="ch7-02.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-02.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-02.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-02.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-02.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-02.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-02.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-02.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-10"><a class="header" href="#题目要求-10">题目要求</a></h2>
<p>在操作系统的任务调度优先级处理过程中，当某些任务队列需要按相反的顺序处理时，可以使用任务队列的反转操作来实现。</p>
<p>给定一个任务队列，按每 𝑘 个节点一组进行翻转，返回修改后的队列。这里的 k 是一个正整数，并且小于或等于队列的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。不能只是单纯地改变节点内部的值，而是需要实际进行节点交换。</p>
<p>你需要实现一个函数 <code>reverse_task_queue_by_group</code>，该函数用于按组（k）反转一个任务队列。</p>
<h2 id="示例-1"><a class="header" href="#示例-1">示例</a></h2>
<p>假设我们有一个任务队列：</p>
<p>原始队列：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</p>
<p>调用 <code>reverse_task_queue_by_group(head,2)</code> 后，返回的新队列应该是：</p>
<p>反转后的队列：2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5</p>
<h2 id="输入-10"><a class="header" href="#输入-10">输入</a></h2>
<p>一组任务 id 组成的队列，由 <code>,</code> 分割，比如 1,2,3,4,5</p>
<h2 id="输出-10"><a class="header" href="#输出-10">输出</a></h2>
<p>打印反转后的任务队列</p>
<p>Reversed queue: 2 1 4 3 5</p>
<h2 id="已有代码介绍-10"><a class="header" href="#已有代码介绍-10">已有代码介绍</a></h2>
<p>任务队列的节点由以下结构体表示：</p>
<pre><code class="language-c">typedef struct TaskNode {
    int task_id;
    struct TaskNode *next;
} TaskNode;
</code></pre>
<h2 id="提示-10"><a class="header" href="#提示-10">提示</a></h2>
<ul>
<li>类似于“滑动窗口”，多维护一个指针，用于记录窗口的开始和末尾。</li>
<li>在原地操作即可，不需要申请新的内存空间。</li>
<li>先读懂框架，再做题！</li>
</ul>
<h2 id="注意事项-10"><a class="header" href="#注意事项-10">注意事项</a></h2>
<ul>
<li>确保在原地进行操作</li>
<li>确保对最后一部分的不足 k 的子队列的处理</li>
<li>确保不是值操作而是对指针操作</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十二题---内核模块---打印-hello-world"><a class="header" href="#第十二题---内核模块---打印-hello-world">第十二题 - 内核模块 - 打印 hello world</a></h1>
<h2 id="本节目录-27"><a class="header" href="#本节目录-27">本节目录</a></h2>
<ul>
<li><a href="ch7-03.html#%E7%AC%AC%E5%8D%81%E4%BA%8C%E9%A2%98---%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97---%E6%89%93%E5%8D%B0-hello-world">第十二题 - 内核模块 - 打印 hello world</a>
<ul>
<li><a href="ch7-03.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-03.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-03.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-03.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-03.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-03.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-03.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-11"><a class="header" href="#题目要求-11">题目要求</a></h2>
<p>编写一个内核模块，打印 <code>hello world!</code>。</p>
<h2 id="输入-11"><a class="header" href="#输入-11">输入</a></h2>
<p>无</p>
<h2 id="输出-11"><a class="header" href="#输出-11">输出</a></h2>
<p>打印 <code>hello world!</code></p>
<h2 id="已有代码介绍-11"><a class="header" href="#已有代码介绍-11">已有代码介绍</a></h2>
<p>模块初始化函数 hello_init 在模块加载时执行，需要正确输出<code>hello world!</code>。</p>
<p>模块退出函数 hello_exit 在模块卸载时执行，打印卸载信息。</p>
<h2 id="提示-11"><a class="header" href="#提示-11">提示</a></h2>
<ul>
<li>按照代码内的提示即可完成任务</li>
</ul>
<h2 id="注意事项-11"><a class="header" href="#注意事项-11">注意事项</a></h2>
<ul>
<li>注意“输出语句”的使用！</li>
<li>注意要同时输出“KERNEL INFO”！</li>
<li>(可以直接复制题目目录内的<code>README.md</code>最后处提供的输出代码)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十三题---内核模块---阶乘计算"><a class="header" href="#第十三题---内核模块---阶乘计算">第十三题 - 内核模块 - 阶乘计算</a></h1>
<h2 id="本节目录-28"><a class="header" href="#本节目录-28">本节目录</a></h2>
<ul>
<li><a href="ch7-04.html#%E7%AC%AC%E5%8D%81%E4%B8%89%E9%A2%98---%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97---%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97">第十三题 - 内核模块 - 阶乘计算</a>
<ul>
<li><a href="ch7-04.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-04.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-04.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-04.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-04.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-04.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-04.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-04.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-12"><a class="header" href="#题目要求-12">题目要求</a></h2>
<p>写一个内核模块，实现计算给定整数的阶乘。</p>
<p>给定整数应通过一个名为 <code>factorial_input</code> 的 kernel parameter 传入。</p>
<h2 id="示例-2"><a class="header" href="#示例-2">示例</a></h2>
<p>输入：5 输出：120</p>
<p>$5 \times 4 \times 3 \times 2 \times 1 = 120$</p>
<h2 id="输入-12"><a class="header" href="#输入-12">输入</a></h2>
<p>一个整数 n（n &gt;= 0）</p>
<h2 id="输出-12"><a class="header" href="#输出-12">输出</a></h2>
<p>整数 n 的阶乘值</p>
<h2 id="已有代码介绍-12"><a class="header" href="#已有代码介绍-12">已有代码介绍</a></h2>
<p>模块初始化函数 factorial_init 在模块加载时执行，需要正确计算并输出阶乘。</p>
<p>模块退出函数 factorial_exit 在模块卸载时执行，打印卸载信息。</p>
<h2 id="提示-12"><a class="header" href="#提示-12">提示</a></h2>
<ul>
<li>可以使用递归</li>
<li>也可以使用 for 循环</li>
</ul>
<h2 id="注意事项-12"><a class="header" href="#注意事项-12">注意事项</a></h2>
<ul>
<li>注意“输出语句”的使用！</li>
<li>注意要同时输出“KERNEL INFO”！</li>
<li>(可以直接复制题目目录内的<code>README.md</code>最后处提供的输出代码)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十四题---内核模块---字符串反转"><a class="header" href="#第十四题---内核模块---字符串反转">第十四题 - 内核模块 - 字符串反转</a></h1>
<h2 id="本节目录-29"><a class="header" href="#本节目录-29">本节目录</a></h2>
<ul>
<li><a href="ch7-05.html#%E7%AC%AC%E5%8D%81%E5%9B%9B%E9%A2%98---%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97---%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC">第十四题 - 内核模块 - 字符串反转</a>
<ul>
<li><a href="ch7-05.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-05.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-05.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-05.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-05.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-05.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-05.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-05.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-13"><a class="header" href="#题目要求-13">题目要求</a></h2>
<p>编写一个内核模块，接收一个字符串作为输入，将其反转后输出。</p>
<p>给定字符串应通过一个名为 <code>reverse_string_input</code> 的 kernel parameter 传入。</p>
<h2 id="示例-3"><a class="header" href="#示例-3">示例</a></h2>
<p>输入：hello 输出：olleh</p>
<h2 id="输入-13"><a class="header" href="#输入-13">输入</a></h2>
<p>一个字符串（长度 &gt;0）。</p>
<h2 id="输出-13"><a class="header" href="#输出-13">输出</a></h2>
<p>反转后的字符串。</p>
<h2 id="已有代码介绍-13"><a class="header" href="#已有代码介绍-13">已有代码介绍</a></h2>
<p>模块初始化函数 reverse_init 在模块加载时执行，需要正确翻转给定的字符串并返回。</p>
<p>模块退出函数 reverse_exit 在模块卸载时执行，打印卸载信息。</p>
<h2 id="提示-13"><a class="header" href="#提示-13">提示</a></h2>
<ul>
<li>在原地执行字符串翻转操作</li>
<li>注意字符串的长度大于 0</li>
</ul>
<h2 id="注意事项-13"><a class="header" href="#注意事项-13">注意事项</a></h2>
<ul>
<li>注意字符串的长度要大于 0！</li>
<li>要在原地操作字符串</li>
<li>注意“输出语句”的使用！</li>
<li>注意要同时输出“KERNEL INFO”！</li>
<li>(可以直接复制题目目录内的<code>README.md</code>最后处提供的输出代码)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十五题---内核模块---平均数计算"><a class="header" href="#第十五题---内核模块---平均数计算">第十五题 - 内核模块 - 平均数计算</a></h1>
<h2 id="本节目录-30"><a class="header" href="#本节目录-30">本节目录</a></h2>
<ul>
<li><a href="ch7-06.html#%E7%AC%AC%E5%8D%81%E4%BA%94%E9%A2%98---%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97---%E5%B9%B3%E5%9D%87%E6%95%B0%E8%AE%A1%E7%AE%97">第十五题 - 内核模块 - 平均数计算</a>
<ul>
<li><a href="ch7-06.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-06.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-06.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-06.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-06.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-06.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-06.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-06.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-14"><a class="header" href="#题目要求-14">题目要求</a></h2>
<p>编写一个内核模块，</p>
<p>给定的数据应通过一个名为 <code>average_input</code> 的 kernel parameter 传入，使用 <code>,</code> 分割。</p>
<h2 id="示例-4"><a class="header" href="#示例-4">示例</a></h2>
<p>输入：1,2,3,4,5 输出：3</p>
<h2 id="输入-14"><a class="header" href="#输入-14">输入</a></h2>
<p>一组数字，使用 <code>,</code> 分割。</p>
<h2 id="输出-14"><a class="header" href="#输出-14">输出</a></h2>
<p>一个平均数。</p>
<h2 id="已有代码介绍-14"><a class="header" href="#已有代码介绍-14">已有代码介绍</a></h2>
<p>模块初始化函数 average_init 在模块加载时执行，需要正确计算给定数组的平均数。</p>
<p>模块退出函数 average_exit 在模块卸载时执行，打印卸载信息。</p>
<h2 id="提示-14"><a class="header" href="#提示-14">提示</a></h2>
<ul>
<li>要理解 <code>module_param_array</code> 是如何工作的</li>
<li>在中文注释处完善逻辑</li>
</ul>
<h2 id="注意事项-14"><a class="header" href="#注意事项-14">注意事项</a></h2>
<ul>
<li>注意处理，使得<code>average_input_size &lt; MAX_ARRAY_SIZE</code></li>
<li>注意“输出语句”的使用！</li>
<li>注意要同时输出“KERNEL INFO”！</li>
<li>(可以直接复制题目目录内的<code>README.md</code>最后处提供的输出代码)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十六题---内核模块---线性查找"><a class="header" href="#第十六题---内核模块---线性查找">第十六题 - 内核模块 - 线性查找</a></h1>
<h2 id="本节目录-31"><a class="header" href="#本节目录-31">本节目录</a></h2>
<ul>
<li><a href="ch7-07.html#%E7%AC%AC%E5%8D%81%E5%85%AD%E9%A2%98---%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97---%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE">第十六题 - 内核模块 - 线性查找</a>
<ul>
<li><a href="ch7-07.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-07.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-07.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-07.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-07.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-07.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-07.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-07.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-15"><a class="header" href="#题目要求-15">题目要求</a></h2>
<p>编写一个内核模块，</p>
<p>给定的数据应通过一个名为 <code>ls_array_input</code> 的 kernel parameter 传入，使用 <code>,</code> 分割。</p>
<p>查找的目标应通过一个名为 <code>ls_target</code> 的 kernel parameter 传入。</p>
<h2 id="示例-5"><a class="header" href="#示例-5">示例</a></h2>
<p>输入： 1. 3,6,9,12,15 2. 12 输出：3</p>
<h2 id="输入-15"><a class="header" href="#输入-15">输入</a></h2>
<p>两个参数：</p>
<ul>
<li>一组数字，使用 <code>,</code> 分割。</li>
<li>一个数字，必须包含在上述组中。</li>
</ul>
<h2 id="输出-15"><a class="header" href="#输出-15">输出</a></h2>
<p>目标在给定数组中的下标。</p>
<h2 id="已有代码介绍-15"><a class="header" href="#已有代码介绍-15">已有代码介绍</a></h2>
<p>模块初始化函数 search_init 在模块加载时执行，需要线性查找对应元素的下标，如果找不到，为了程序的鲁棒性，可以返回<code>-1</code>。</p>
<p>模块退出函数 search_exit 在模块卸载时执行，打印卸载信息。</p>
<h2 id="提示-15"><a class="header" href="#提示-15">提示</a></h2>
<ul>
<li>可以使用<code>-1</code>作为找不到下标时的返回值</li>
<li>线性查找，遍历即可</li>
</ul>
<h2 id="注意事项-15"><a class="header" href="#注意事项-15">注意事项</a></h2>
<ul>
<li>注意“输出语句”的使用！</li>
<li>注意要同时输出“KERNEL INFO”！</li>
<li>(可以直接复制题目目录内的<code>README.md</code>最后处提供的输出代码)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十七题---内核模块---延时打印字符串"><a class="header" href="#第十七题---内核模块---延时打印字符串">第十七题 - 内核模块 - 延时打印字符串</a></h1>
<h2 id="本节目录-32"><a class="header" href="#本节目录-32">本节目录</a></h2>
<ul>
<li><a href="ch7-08.html#%E7%AC%AC%E5%8D%81%E4%B8%83%E9%A2%98---%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97---%E5%BB%B6%E6%97%B6%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2">第十七题 - 内核模块 - 延时打印字符串</a>
<ul>
<li><a href="ch7-08.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-08.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-08.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-08.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-08.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-08.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-08.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-08.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-16"><a class="header" href="#题目要求-16">题目要求</a></h2>
<p>编写一个内核模块，延时打印一串字符 Delay 2s!</p>
<h2 id="示例-6"><a class="header" href="#示例-6">示例</a></h2>
<p>2s 后输出 <code>hello world!</code></p>
<h2 id="输入-16"><a class="header" href="#输入-16">输入</a></h2>
<p>无</p>
<h2 id="输出-16"><a class="header" href="#输出-16">输出</a></h2>
<p>延时 2s 后打印 Delay 2s!。</p>
<h2 id="已有代码介绍-16"><a class="header" href="#已有代码介绍-16">已有代码介绍</a></h2>
<p>模块初始化函数 delay_init 在模块加载时执行，之后要先延时，再打印。</p>
<p>模块退出函数 delay_exit 在模块卸载时执行，打印卸载信息。</p>
<h2 id="提示-16"><a class="header" href="#提示-16">提示</a></h2>
<ul>
<li>查找资料时，可以关注“Linux 系统模块”</li>
<li>使用<code>msleep (2000);</code>进行延时</li>
</ul>
<h2 id="注意事项-16"><a class="header" href="#注意事项-16">注意事项</a></h2>
<ul>
<li>注意“输出语句”的使用！</li>
<li>注意要同时输出“KERNEL INFO”！</li>
<li>(可以直接复制题目目录内的<code>README.md</code>最后处提供的输出代码)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十八题---risc-v-汇编---条件返回"><a class="header" href="#第十八题---risc-v-汇编---条件返回">第十八题 - Risc-V 汇编 - 条件返回</a></h1>
<h2 id="本节目录-33"><a class="header" href="#本节目录-33">本节目录</a></h2>
<ul>
<li><a href="ch7-09.html#%E7%AC%AC%E5%8D%81%E5%85%AB%E9%A2%98---risc-v-%E6%B1%87%E7%BC%96---%E6%9D%A1%E4%BB%B6%E8%BF%94%E5%9B%9E">第十八题 - Risc-V 汇编 - 条件返回</a>
<ul>
<li><a href="ch7-09.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-09.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-09.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-09.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-09.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-09.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-09.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-09.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-17"><a class="header" href="#题目要求-17">题目要求</a></h2>
<p>编写一个 C 函数，名为 conditional_jump。该函数接受两个整数参数，如果第一个参数大于等于第二个参数，则返回第一个参数的值，否则返回第二个参数的值。</p>
<h2 id="示例-7"><a class="header" href="#示例-7">示例</a></h2>
<p>输入：a = 5, b = 3，输出：Result: 5</p>
<h2 id="输入-17"><a class="header" href="#输入-17">输入</a></h2>
<p>两个整数 a，b，以空格分隔，表示函数的两个参数。输入保证在 int 类型范围内。</p>
<h2 id="输出-17"><a class="header" href="#输出-17">输出</a></h2>
<p>根据条件跳转逻辑，返回格式 Result: num，num 就是要返回的整数值</p>
<h2 id="已有代码介绍-17"><a class="header" href="#已有代码介绍-17">已有代码介绍</a></h2>
<p>通过 main 调用，由内联汇编代码写的函数。</p>
<h2 id="提示-17"><a class="header" href="#提示-17">提示</a></h2>
<ul>
<li>使用 RISC-V 汇编指令替换 find_max 函数中的 PLACEHOLDER。</li>
<li>"bge" 指令用于在比较操作中，当大于或等于时跳转。</li>
<li>可以使用“%1, %2”取得函数传入的第一个和第二个参数</li>
</ul>
<h2 id="注意事项-17"><a class="header" href="#注意事项-17">注意事项</a></h2>
<ul>
<li>保持输出格式为 Result: num。</li>
<li>使用内联汇编！</li>
<li>注意汇编的寄存器参数和直接参数的差别！</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十九题---risc-v-汇编---最大公因数求解"><a class="header" href="#第十九题---risc-v-汇编---最大公因数求解">第十九题 - Risc-V 汇编 - 最大公因数求解</a></h1>
<h2 id="本节目录-34"><a class="header" href="#本节目录-34">本节目录</a></h2>
<ul>
<li><a href="ch7-10.html#%E7%AC%AC%E5%8D%81%E4%B9%9D%E9%A2%98---risc-v-%E6%B1%87%E7%BC%96---%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%B1%82%E8%A7%A3">第十九题 - Risc-V 汇编 - 最大公因数求解</a>
<ul>
<li><a href="ch7-10.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-10.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-10.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-10.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-10.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-10.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-10.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-10.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-18"><a class="header" href="#题目要求-18">题目要求</a></h2>
<p>编写一个 C 语言函数 gcd，接受两个整数 a 和 b，利用辗转相减法计算它们的最大公因数，并返回结果。然后编写一个程序调用该函数，并输出结果</p>
<h2 id="示例-8"><a class="header" href="#示例-8">示例</a></h2>
<p>输入 12 18，输出 6</p>
<h2 id="输入-18"><a class="header" href="#输入-18">输入</a></h2>
<p>两个整数 a 和 b 作为程序参数，以空格分隔</p>
<h2 id="输出-18"><a class="header" href="#输出-18">输出</a></h2>
<p>输出样式 GCD of a and b is num, num 是一个整数，表示输入整数 a 和 b 的最大公因数。</p>
<h2 id="已有代码介绍-18"><a class="header" href="#已有代码介绍-18">已有代码介绍</a></h2>
<p>通过 main 调用，由内联汇编代码写的函数。</p>
<h2 id="提示-18"><a class="header" href="#提示-18">提示</a></h2>
<ul>
<li>使用 RISC-V 汇编指令替换 gcd 函数中的 PLACEHOLDER。</li>
<li>"beq" 指令用于在比较操作中，当等于时跳转。</li>
<li>"blt" 指令用于在比较操作中，当小于时跳转。</li>
</ul>
<h2 id="注意事项-18"><a class="header" href="#注意事项-18">注意事项</a></h2>
<ul>
<li>保持输出格式为 GCD of a and b is num。</li>
<li>使用内联汇编！</li>
<li>注意汇编的寄存器参数和直接参数的差别！</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二十题---risc-v-汇编---数组元素查找"><a class="header" href="#第二十题---risc-v-汇编---数组元素查找">第二十题 - Risc-V 汇编 - 数组元素查找</a></h1>
<h2 id="本节目录-35"><a class="header" href="#本节目录-35">本节目录</a></h2>
<ul>
<li><a href="ch7-11.html#%E7%AC%AC%E4%BA%8C%E5%8D%81%E9%A2%98---risc-v-%E6%B1%87%E7%BC%96---%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%9F%A5%E6%89%BE">第二十题 - Risc-V 汇编 - 数组元素查找</a>
<ul>
<li><a href="ch7-11.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ch7-11.html#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li>
<li><a href="ch7-11.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="ch7-11.html#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="ch7-11.html#%E8%BE%93%E5%87%BA">输出</a></li>
<li><a href="ch7-11.html#%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D">已有代码介绍</a></li>
<li><a href="ch7-11.html#%E6%8F%90%E7%A4%BA">提示</a></li>
<li><a href="ch7-11.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
<h2 id="题目要求-19"><a class="header" href="#题目要求-19">题目要求</a></h2>
<p>设计一个 C 语言函数 find_value，接受一个整数数组 arr、数组的长度 n、一个目标值 target，以及一个起始索引 start_index，返回目标值在数组中从指定起始索引开始的第一次出现的索引。如果目标值不在数组中或起始索引超出数组范围，则返回 -1。然后编写一个程序调用该函数，并输出结果。</p>
<h2 id="示例-9"><a class="header" href="#示例-9">示例</a></h2>
<p>输入：</p>
<pre><code>1,2,3,4,5
5
3
1
</code></pre>
<p>输出：</p>
<pre><code>Index of target from start index: 2
</code></pre>
<h2 id="输入-19"><a class="header" href="#输入-19">输入</a></h2>
<p>共需要 4 个参数：</p>
<ol>
<li>一个整数数组 arr，以逗号分割，比如 1,2,3,4,5；</li>
<li>一个整数 n；</li>
<li>一个目标 target；</li>
<li>一个索引 start_index；
输入保证在 int 类型范围内。</li>
</ol>
<h2 id="输出-19"><a class="header" href="#输出-19">输出</a></h2>
<p>返回字符串格式 Index of target from start index: INDEX，INDEX 表示 target 在指定数组范围内的索引，若没有该元素，返回字符串 Target not found or start index out of range.。`</p>
<h2 id="已有代码介绍-19"><a class="header" href="#已有代码介绍-19">已有代码介绍</a></h2>
<p>通过 main 调用，由内联汇编代码写的函数。</p>
<h2 id="提示-19"><a class="header" href="#提示-19">提示</a></h2>
<ul>
<li>使用 RISC-V 汇编指令替换 gcd 函数中的 PLACEHOLDER。</li>
<li>a * 4 &lt;=&gt; a &lt;&lt; 2</li>
<li>"slli" 指令用于将某个数左移指定位后，存入指定的寄存器，具体参数请自行查阅手册</li>
</ul>
<h2 id="注意事项-19"><a class="header" href="#注意事项-19">注意事项</a></h2>
<ul>
<li>保持输出格式为 Index of target from start index: INDEX。</li>
<li>使用内联汇编！</li>
<li>注意汇编的寄存器参数和直接参数的差别！</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-a---可供参考的各种资料汇总"><a class="header" href="#附录-a---可供参考的各种资料汇总">附录 A - 可供参考的各种资料汇总</a></h1>
<h2 id="本节目录-36"><a class="header" href="#本节目录-36">本节目录</a></h2>
<ul>
<li><a href="ap-A.html#%E9%99%84%E5%BD%95-a---%E5%8F%AF%E4%BE%9B%E5%8F%82%E8%80%83%E7%9A%84%E5%90%84%E7%A7%8D%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB">附录 A - 可供参考的各种资料汇总</a>
<ul>
<li><a href="ap-A.html#%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">本节目录</a></li>
<li><a href="ap-A.html#risc-v-%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">Risc-V 参考文献</a></li>
<li><a href="ap-A.html#linux-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3">Linux 内核文档</a></li>
<li><a href="ap-A.html#risc-v-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E7%9A%84-linux-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">Risc-V 开发板上的 Linux 启动流程</a></li>
<li><a href="ap-A.html#%E6%9B%B4%E8%AF%A6%E7%BB%86%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B">更详细的操作系统教程</a></li>
</ul>
</li>
</ul>
<h2 id="risc-v-参考文献"><a class="header" href="#risc-v-参考文献">Risc-V 参考文献</a></h2>
<p><img src="./resource/RV%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE.png" alt="Risc-V参考文献" /></p>
<ul>
<li>参考二：<a href="https://github.com/isrc-cas/riscv-isa-manual-cn">https://github.com/isrc-cas/riscv-isa-manual-cn</a></li>
<li>参考四：<a href="https://github.com/riscv/riscv-plic-spec">https://github.com/riscv/riscv-plic-spec</a></li>
</ul>
<h2 id="linux-内核文档"><a class="header" href="#linux-内核文档">Linux 内核文档</a></h2>
<p><a href="https://www.kernel.org/doc/html/v6.9-rc7/index.html">https://www.kernel.org/doc/html/v6.9-rc7/index.html</a></p>
<h2 id="risc-v-开发板上的-linux-启动流程"><a class="header" href="#risc-v-开发板上的-linux-启动流程">Risc-V 开发板上的 Linux 启动流程</a></h2>
<p><a href="https://linux-sunxi.org/Allwinner_Nezha">https://linux-sunxi.org/Allwinner_Nezha</a></p>
<h2 id="更详细的操作系统教程"><a class="header" href="#更详细的操作系统教程">更详细的操作系统教程</a></h2>
<p><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/index.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/index.html</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
