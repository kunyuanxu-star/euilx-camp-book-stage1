# 第十题 - 数据结构(队列) - 合并两个队列

## 本节目录

- [第十题 - 数据结构(队列) - 合并两个队列](#第十题---数据结构队列---合并两个队列)
  - [本节目录](#本节目录)
  - [题目要求](#题目要求)
  - [示例](#示例)
  - [输入](#输入)
  - [输出](#输出)
  - [已有代码介绍](#已有代码介绍)
  - [提示](#提示)
  - [注意事项](#注意事项)

## 题目要求

将两个任务队列（例如运行队列）合并在一起，这在多核处理器中尤为常见，当某个处理器的任务队列需要与另一个处理器的任务队列合并时，可以使用这一操作。

你需要实现一个函数 `merge_task_queues`，该函数用于合并两个已经排序的任务队列。每个任务队列由 TaskNode 结构体表示，任务队列按任务 ID (task_id) 从小到大排序。合并后的任务队列也需要保持有序。

## 示例

假设我们有两个任务队列：

队列 A：1 -> 3 -> 5
队列 B：2 -> 4 -> 6
调用 `merge_task_queues(A, B)` 后，返回的新队列应该是：

合并后的队列：1 -> 2 -> 3 -> 4 -> 5 -> 6

## 输入

一组任务 id 组成的的队列，由 `,` 分割，比如 1,3,5。
另一组任务 id 组成的的队列，由 `,` 分割，比如 2,4,6。

## 输出

打印合并后的任务队列：

Merged Queue: 1 2 3 4 5 6

## 已有代码介绍

任务队列的节点由以下结构体表示：

```c
typedef struct TaskNode {
    int task_id;
    struct TaskNode *next;
} TaskNode;
```

## 提示

- 初始的任务队列已经安装升序排序完毕，合并后的队列也要以升序排列。
- 在原地操作即可，不需要申请新的内存空间。
- 同时遍历两个队列，不断选出最小的任务 id，然后将其插入到新队列的末尾。

## 注意事项

记得判断退出了 while 循环后，是否仍然有非空队列，如果有，则应该进一步合并。
