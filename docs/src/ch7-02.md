# 第十一题 - 数据结构(队列) - 按组反转一个队列

## 本节目录

- [第十一题 - 数据结构(队列) - 按组反转一个队列](#第十一题---数据结构队列---按组反转一个队列)
  - [本节目录](#本节目录)
  - [题目要求](#题目要求)
  - [示例](#示例)
  - [输入](#输入)
  - [输出](#输出)
  - [已有代码介绍](#已有代码介绍)
  - [提示](#提示)
  - [注意事项](#注意事项)

## 题目要求

在操作系统的任务调度优先级处理过程中，当某些任务队列需要按相反的顺序处理时，可以使用任务队列的反转操作来实现。

给定一个任务队列，按每 𝑘 个节点一组进行翻转，返回修改后的队列。这里的 k 是一个正整数，并且小于或等于队列的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。不能只是单纯地改变节点内部的值，而是需要实际进行节点交换。

你需要实现一个函数 `reverse_task_queue_by_group`，该函数用于按组（k）反转一个任务队列。

## 示例

假设我们有一个任务队列：

原始队列：1 -> 2 -> 3 -> 4 -> 5

调用 `reverse_task_queue_by_group(head,2)` 后，返回的新队列应该是：

反转后的队列：2 -> 1 -> 4 -> 3 -> 5

## 输入

一组任务 id 组成的队列，由 `,` 分割，比如 1,2,3,4,5

## 输出

打印反转后的任务队列

Reversed queue: 2 1 4 3 5

## 已有代码介绍

任务队列的节点由以下结构体表示：

```c
typedef struct TaskNode {
    int task_id;
    struct TaskNode *next;
} TaskNode;
```

## 提示

- 类似于“滑动窗口”，多维护一个指针，用于记录窗口的开始和末尾。
- 在原地操作即可，不需要申请新的内存空间。
- 先读懂框架，再做题！

## 注意事项

- 确保在原地进行操作
- 确保对最后一部分的不足 k 的子队列的处理
- 确保不是值操作而是对指针操作
